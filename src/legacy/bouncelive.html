<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <title>BounceLive - Solve the Bounce!</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700;800;900&display=swap');
        
        :root {
            --primary-gradient: linear-gradient(135deg, #22D3EE 0%, #0891B2 100%);
            --success-gradient: linear-gradient(135deg, #FBBF24 0%, #F59E0B 100%);
            --danger-gradient: linear-gradient(135deg, #F87171 0%, #EF4444 100%);
            --glass-bg: rgba(71, 85, 105, 0.85);
            --glass-border: rgba(255, 255, 255, 0.15);
            --shadow-soft: 0 8px 32px rgba(0, 0, 0, 0.25);
            --shadow-medium: 0 12px 40px rgba(0, 0, 0, 0.3);
            --text-primary: #F1F5F9;
            --text-secondary: #CBD5E1;
            --text-muted: #94A3B8;
        }
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        html, body {
            overflow: hidden;
            background: linear-gradient(135deg, #475569 0%, #3D4A5F 50%, #475569 100%);
            font-family: 'Nunito', -apple-system, BlinkMacSystemFont, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            min-height: -webkit-fill-available;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        #game-container { 
            position: relative; 
            background: linear-gradient(180deg, #475569 0%, #3D4A5F 100%);
            border-radius: 28px;
            overflow: hidden;
            box-shadow: var(--shadow-medium), inset 0 1px 0 rgba(255,255,255,0.1);
            touch-action: none;
        }
        
        canvas { display: block; touch-action: none; }
        
        /* ========== WELCOME SCREEN ========== */
        #welcome-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(180deg, #4D5A6F 0%, #475569 50%, #3D4A5F 100%);
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            padding: 40px 25px;
            z-index: 100;
            transition: opacity 0.6s cubic-bezier(0.4, 0, 0.2, 1), 
                        transform 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        /* Title group - shifted UP 75px from its natural position */
        .welcome-title-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 20px;
        }
        
        /* Instruction stack (subtitle + rules) - centered between title and bottom */
        .welcome-instruction-stack {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: auto;
            margin-bottom: auto;
        }
        
        /* Bottom group (highest reached + start button) - shifted DOWN 75px */
        .welcome-bottom-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 20px;
        }
        
        #welcome-screen::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background-image: radial-gradient(circle at 2px 2px, rgba(34, 211, 238, 0.04) 1px, transparent 0);
            background-size: 24px 24px;
            pointer-events: none;
        }
        
        #welcome-screen.hidden {
            opacity: 0;
            transform: scale(0.95) translateY(-20px);
            pointer-events: none;
        }
        
        #welcome-screen h1 {
            font-size: 36px;
            font-weight: 900;
            background: linear-gradient(135deg, #22D3EE 0%, #67E8F9 50%, #FBBF24 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 12px;
            text-align: center;
            letter-spacing: -0.5px;
            animation: titlePulse 3s ease-in-out infinite;
            position: relative;
            z-index: 1;
            text-shadow: 0 0 40px rgba(34, 211, 238, 0.3);
        }
        
        @keyframes titlePulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }
        
        #welcome-screen .subtitle {
            font-size: 19px;
            font-weight: 600;
            color: var(--text-secondary);
            text-align: center;
            margin-bottom: 40px;
            line-height: 1.6;
            position: relative;
            z-index: 1;
        }
        
        .highlight-all {
            font-weight: 800;
            color: #F6D365;
        }
        
        #welcome-screen .rules-box {
            background: var(--glass-bg);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            border-radius: 20px;
            padding: 24px 28px;
            margin-bottom: 0;
            width: 90%;
            max-width: 300px;
            box-shadow: var(--shadow-soft);
            position: relative;
            z-index: 1;
            animation: slideUp 0.6s cubic-bezier(0.4, 0, 0.2, 1) 0.2s both;
        }
        
        @keyframes slideUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        #welcome-screen .rules-box ul { list-style: none; padding: 0; }
        
        #welcome-screen .rules-box li {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 16px;
            padding-left: 28px;
            position: relative;
            line-height: 1.5;
        }
        
        #welcome-screen .rules-box li:last-child { margin-bottom: 0; }
        
        #welcome-screen .rules-box li::before {
            content: '';
            position: absolute;
            left: 0; top: 50%;
            transform: translateY(-50%);
            width: 18px; height: 18px;
            background: linear-gradient(135deg, #22D3EE 0%, #06B6D4 100%);
            border-radius: 50%;
            opacity: 0.9;
        }
        
        #welcome-screen .rules-box li::after {
            content: '✓';
            position: absolute;
            left: 4px; top: 50%;
            transform: translateY(-50%);
            font-size: 10px;
            color: white;
            font-weight: 700;
        }
        
        #start-btn {
            padding: 18px 55px;
            font-size: 20px;
            font-weight: 800;
            font-family: 'Nunito', sans-serif;
            background: linear-gradient(135deg, #22D3EE 0%, #06B6D4 100%);
            color: #0F172A;
            border: none;
            border-radius: 16px;
            cursor: pointer;
            box-shadow: 0 8px 24px rgba(34, 211, 238, 0.4), inset 0 1px 0 rgba(255,255,255,0.3);
            transition: transform 0.2s cubic-bezier(0.4, 0, 0.2, 1), box-shadow 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            min-height: 56px;
            position: relative;
            z-index: 1;
            animation: slideUp 0.6s cubic-bezier(0.4, 0, 0.2, 1) 0.4s both;
            letter-spacing: 0.5px;
            margin-top: 0;
        }
        
        .highest-reached {
            margin-top: 0;
            margin-bottom: 12px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 6px;
            animation: slideUp 0.6s cubic-bezier(0.4, 0, 0.2, 1) 0.35s both;
        }
        
        .highest-label {
            color: rgba(251, 191, 36, 0.9);
            font-size: 16px;
            font-weight: 600;
            text-shadow: 0 0 12px rgba(251, 191, 36, 0.3);
        }
        
        .highest-value {
            color: #FBBF24;
            font-size: 20px;
            font-weight: 800;
            text-shadow: 0 0 16px rgba(251, 191, 36, 0.5);
        }
        
        #start-btn:hover {
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 12px 32px rgba(34, 211, 238, 0.5), inset 0 1px 0 rgba(255,255,255,0.3);
        }
        
        #start-btn:active {
            transform: translateY(1px) scale(0.98);
            box-shadow: 0 4px 16px rgba(34, 211, 238, 0.4);
        }
        
        #debug-overlay {
            position: absolute; top: 100px; left: 10px;
            background: rgba(0, 0, 0, 0.8); color: #4ade80;
            padding: 12px 16px; font-family: 'SF Mono', Monaco, monospace; font-size: 11px;
            border-radius: 12px; display: none; z-index: 20;
            backdrop-filter: blur(10px);
        }
        
        /* ========== GAME OVERLAY ========== */
        #game-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(15, 23, 42, 0.7);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            display: none; justify-content: center; align-items: center; flex-direction: column;
            z-index: 50;
        }
        
        #game-overlay.active { display: flex; animation: fadeIn 0.3s ease forwards; }
        
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        
        .overlay-card {
            background: var(--glass-bg);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 28px;
            padding: 40px 50px;
            text-align: center;
            box-shadow: var(--shadow-medium);
            border: 1px solid var(--glass-border);
            animation: modalSlideIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
            transform: scale(0.9) translateY(20px);
            opacity: 0;
        }
        
        @keyframes modalSlideIn { to { transform: scale(1) translateY(0); opacity: 1; } }
        
        #game-overlay h1 { font-size: 32px; font-weight: 900; margin-bottom: 8px; letter-spacing: -0.5px; }
        
        #game-overlay.win h1 { 
            background: linear-gradient(135deg, #22D3EE 0%, #4ADE80 100%);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;
        }
        
        #game-overlay.fail h1 { 
            background: var(--danger-gradient);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;
        }
        
        #game-overlay .level-complete { font-size: 15px; color: var(--text-secondary); margin-bottom: 20px; font-weight: 600; }
        
        .star-rating { display: flex; justify-content: center; gap: 8px; margin-bottom: 28px; }
        
        .star {
            font-size: 32px; color: #475569;
            transition: all 0.3s ease;
        }
        
        .star.filled {
            color: #fbbf24;
            text-shadow: 0 0 20px rgba(251, 191, 36, 0.5);
            animation: starPop 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        
        .star:nth-child(2).filled { animation-delay: 0.1s; }
        .star:nth-child(3).filled { animation-delay: 0.2s; }
        
        @keyframes starPop { 0% { transform: scale(0); } 50% { transform: scale(1.3); } 100% { transform: scale(1); } }
        
        .overlay-btn {
            padding: 16px 40px; font-size: 16px; font-weight: 700;
            font-family: 'Nunito', sans-serif;
            color: #0F172A; border: none; border-radius: 14px;
            cursor: pointer; transition: transform 0.2s ease, box-shadow 0.2s ease; margin: 8px;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            min-height: 52px; letter-spacing: 0.3px;
        }
        
        .overlay-btn:hover { transform: translateY(-2px); }
        .overlay-btn:active { transform: translateY(1px) scale(0.98); }
        
        #next-level-btn { background: linear-gradient(135deg, #22D3EE 0%, #06B6D4 100%); box-shadow: 0 8px 24px rgba(34, 211, 238, 0.4); }
        #retry-btn { background: linear-gradient(135deg, #7C5CFF 0%, #5B3FD9 100%); box-shadow: 0 8px 24px rgba(124, 92, 255, 0.35); color: white; }
        
        #game-overlay.fail #next-level-btn { display: none; }
        #game-overlay.fail #retry-btn { background: var(--danger-gradient); box-shadow: 0 8px 24px rgba(244, 92, 67, 0.35); color: white; }
        #game-overlay.win #retry-btn { display: none; }
        #game-overlay.win #next-level-btn { display: inline-block; }
        
        /* ========== POWERUP POPOVER ========== */
        #powerup-overlay {
            position: absolute;
            top: 0; left: 0; right: 0;
            bottom: 60px; /* Leave powerup area uncovered */
            background: rgba(0, 0, 0, 0.5);
            z-index: 50;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
        }
        
        #powerup-overlay.active {
            opacity: 1;
            pointer-events: auto;
        }
        
        #powerup-popover {
            position: absolute;
            bottom: 70px;
            left: 12px;
            transform: scale(0.95);
            transform-origin: bottom left;
            background: rgba(51, 65, 85, 0.98);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 14px;
            padding: 16px 20px;
            z-index: 60;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease, transform 0.2s ease;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            text-align: center;
            min-width: 200px;
            --nub-x: 50px;
        }
        
        #powerup-popover.active {
            opacity: 1;
            pointer-events: auto;
            transform: scale(1);
        }
        
        #powerup-popover::after {
            content: '';
            position: absolute;
            bottom: -8px;
            left: var(--nub-x);
            transform: translateX(-50%);
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-top: 8px solid rgba(51, 65, 85, 0.98);
        }
        
        #powerup-popover h3 {
            font-size: 13px;
            font-weight: 600;
            color: #F1F5F9;
            margin: 0 0 12px 0;
            line-height: 1.4;
        }
        
        #powerup-use-btn {
            background: linear-gradient(135deg, #22D3EE 0%, #0891B2 100%);
            color: #0F172A;
            border: none;
            border-radius: 8px;
            padding: 10px 28px;
            font-size: 14px;
            font-weight: 700;
            font-family: 'Nunito', sans-serif;
            cursor: pointer;
            transition: transform 0.15s ease, box-shadow 0.15s ease;
            box-shadow: 0 4px 12px rgba(34, 211, 238, 0.3);
        }
        
        #powerup-use-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 16px rgba(34, 211, 238, 0.4);
        }
        
        #powerup-use-btn:active {
            transform: translateY(1px) scale(0.98);
        }
        
        #powerup-use-btn.disabled {
            background: linear-gradient(135deg, #64748B 0%, #475569 100%);
            color: #94A3B8;
            cursor: default;
            pointer-events: none;
            box-shadow: none;
        }
        
        #powerup-use-btn.disabled:hover,
        #powerup-use-btn.disabled:active {
            transform: none;
            box-shadow: none;
        }
        
        /* R Powerup Popover - same style as T */
        #r-powerup-popover {
            position: absolute;
            bottom: 70px;
            left: 50%;
            transform: translateX(-50%) scale(0.95);
            transform-origin: bottom center;
            background: rgba(51, 65, 85, 0.98);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 14px;
            padding: 16px 20px;
            z-index: 60;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease, transform 0.2s ease;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            text-align: center;
            min-width: 200px;
            --nub-x: 50px;
        }
        
        #r-powerup-popover.active {
            opacity: 1;
            pointer-events: auto;
            transform: scale(1);
        }
        
        #r-powerup-popover::after {
            content: '';
            position: absolute;
            bottom: -8px;
            left: var(--nub-x);
            transform: translateX(-50%);
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-top: 8px solid rgba(51, 65, 85, 0.98);
        }
        
        #r-powerup-popover h3 {
            font-size: 13px;
            font-weight: 600;
            color: #F1F5F9;
            margin: 0 0 12px 0;
            line-height: 1.4;
        }
        
        #r-powerup-use-btn {
            background: linear-gradient(135deg, #F87171 0%, #DC2626 100%);
            color: #0F172A;
            border: none;
            border-radius: 8px;
            padding: 10px 28px;
            font-size: 14px;
            font-weight: 700;
            font-family: 'Nunito', sans-serif;
            cursor: pointer;
            transition: transform 0.15s ease, box-shadow 0.15s ease;
            box-shadow: 0 4px 12px rgba(248, 113, 113, 0.3);
        }
        
        #r-powerup-use-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 16px rgba(248, 113, 113, 0.4);
        }
        
        #r-powerup-use-btn:active {
            transform: translateY(1px) scale(0.98);
        }
        
        #r-powerup-use-btn.disabled {
            background: linear-gradient(135deg, #64748B 0%, #475569 100%);
            color: #94A3B8;
            cursor: default;
            pointer-events: none;
            box-shadow: none;
        }
        
        /* E Powerup Popover - same style as others */
        #e-powerup-popover {
            position: absolute;
            bottom: 70px;
            left: 50%;
            transform: translateX(-50%) scale(0.95);
            transform-origin: bottom center;
            background: rgba(51, 65, 85, 0.98);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 14px;
            padding: 16px 20px;
            z-index: 60;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease, transform 0.2s ease;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            text-align: center;
            min-width: 200px;
            --nub-x: 50px;
        }
        
        #e-powerup-popover.active {
            opacity: 1;
            pointer-events: auto;
            transform: scale(1);
        }
        
        #e-powerup-popover::after {
            content: '';
            position: absolute;
            bottom: -8px;
            left: var(--nub-x);
            transform: translateX(-50%);
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-top: 8px solid rgba(51, 65, 85, 0.98);
        }
        
        #e-powerup-popover h3 {
            font-size: 13px;
            font-weight: 600;
            color: #F1F5F9;
            margin: 0 0 12px 0;
            line-height: 1.4;
        }
        
        #e-powerup-use-btn {
            background: linear-gradient(135deg, #FBBF24 0%, #F59E0B 100%);
            color: #0F172A;
            border: none;
            border-radius: 8px;
            padding: 10px 28px;
            font-size: 14px;
            font-weight: 700;
            font-family: 'Nunito', sans-serif;
            cursor: pointer;
            transition: transform 0.15s ease, box-shadow 0.15s ease;
            box-shadow: 0 4px 12px rgba(251, 191, 36, 0.3);
        }
        
        #e-powerup-use-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 16px rgba(251, 191, 36, 0.4);
        }
        
        #e-powerup-use-btn:active {
            transform: translateY(1px) scale(0.98);
        }
        
        #e-powerup-use-btn.disabled {
            background: linear-gradient(135deg, #64748B 0%, #475569 100%);
            color: #94A3B8;
            cursor: default;
            pointer-events: none;
            box-shadow: none;
        }
        
        /* Remove Selection Overlay - transparent, just for click capture */
        #remove-selection-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 60px;
            background: transparent;
            z-index: 25;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
        }
        
        #remove-selection-overlay.active {
            opacity: 1;
            pointer-events: auto;
        }
        
        /* ========================================
         * LEVEL 1 INSTRUCTIONAL LABELS
         * ======================================== */
        .level1-label {
            position: absolute;
            pointer-events: none;
            font-family: 'Nunito', 'Inter', system-ui, sans-serif;
            z-index: 15;
            transition: opacity 0.3s ease;
        }
        
        .level1-label.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        /* A) Drag instruction: single line, true center */
        #drag-instruction-label {
            font-size: 14px;
            font-weight: 700;
            color: rgba(255, 255, 255, 0.85);
            text-align: center;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
            white-space: nowrap;
            max-width: none;
            left: 50%;
            transform: translateX(-50%);
        }
        
        /* B) Line labels: left-aligned containers */
        .line-label-container {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            justify-content: center;
        }
        
        .line-label {
            font-size: 11px;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.45);
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
            line-height: 1;
        }
        
        /* C) Symmetric spacing: equal gap above and below the line */
        /* The container is vertically centered on the line via transform */
        /* These margins create the visual gap from the invisible "line" center */
        .line-label-top {
            margin-bottom: 4px;
        }
        
        .line-label-bottom {
            margin-top: 4px;
        }
        
        /* ========================================
         * SAFARI PERFORMANCE FIX (COMPREHENSIVE)
         * Safari GPU compositor stalls when backdrop-filter blur
         * is composited over continuously-updating canvas.
         * Solution: Disable ALL blur/shadow/filter/animation on overlays.
         * ======================================== */
        
        /* Compositor hints for smoother overlay transitions */
        #game-overlay,
        .overlay-card {
            will-change: opacity, transform;
        }
        
        /* Safari: COMPLETE disable of ALL expensive effects on overlays */
        body.safari #game-overlay,
        body.safari .overlay-card,
        body.safari #debug-overlay,
        body.safari #powerup-overlay,
        body.safari #powerup-popover,
        body.safari #r-powerup-popover,
        body.safari #e-powerup-popover,
        body.safari #welcome-screen .rules-box {
            backdrop-filter: none !important;
            -webkit-backdrop-filter: none !important;
            filter: none !important;
            box-shadow: none !important;
            text-shadow: none !important;
            animation: none !important;
            transition: none !important;
        }
        
        /* Safari: opaque backgrounds to replace blur effect */
        body.safari #game-overlay {
            background: rgba(15, 23, 42, 0.94) !important;
        }
        
        body.safari .overlay-card {
            background: rgba(30, 41, 59, 0.98) !important;
        }
        
        body.safari #welcome-screen .rules-box {
            background: rgba(30, 41, 59, 0.96) !important;
        }
        
        body.safari #debug-overlay {
            background: rgba(0, 0, 0, 0.94) !important;
        }
        
        body.safari #powerup-popover,
        body.safari #r-powerup-popover,
        body.safari #e-powerup-popover {
            background: rgba(30, 41, 59, 0.98) !important;
        }
        
        /* Safari: disable button shadows and hover animations */
        body.safari .overlay-btn,
        body.safari #next-level-btn,
        body.safari #retry-btn {
            box-shadow: none !important;
            text-shadow: none !important;
            transition: none !important;
        }
        
        /* Safari: disable star pulse animations entirely */
        body.safari .star,
        body.safari .star.filled {
            animation: none !important;
        }
        
        /* Safari: disable overlay h1 text-shadow */
        body.safari #game-overlay h1 {
            text-shadow: none !important;
        }
        
        /* Safari timing info display (debug only) */
        #safari-timing-info {
            display: none;
            font-size: 10px;
            color: rgba(255, 255, 255, 0.5);
            margin-top: 8px;
            font-family: monospace;
        }
        body.safari #safari-timing-info {
            display: block;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        
        <!-- Level 1 Instructional Labels -->
        <div id="drag-instruction-label" class="level1-label hidden">Drag the objects outside of the piece area.</div>
        <div id="ball-line-label-container" class="level1-label line-label-container hidden">
            <div class="line-label line-label-top">Ball</div>
            <div class="line-label line-label-bottom">Line</div>
        </div>
        <div id="basket-line-label-container" class="level1-label line-label-container hidden">
            <div class="line-label line-label-top">Basket</div>
            <div class="line-label line-label-bottom">Line</div>
        </div>
        
        <!-- Welcome Screen -->
        <div id="welcome-screen">
            <div class="welcome-title-group">
                <h1>Solve the Bounce!</h1>
            </div>
            <div class="welcome-instruction-stack">
                <p class="subtitle">Place the shapes such that<br>ball hits <span class="highlight-all">ALL</span> and goes to the basket</p>
                <div class="rules-box">
                    <ul>
                        <li>You can rotate and drag the objects (you can use angle adjust area for fine tuning).</li>
                        <li>Check the level specs on top-right side.</li>
                        <li>Put the ball to the basket within given lives to win!</li>
                        <li>Don't rely too much on corner / curve trajectories!</li>
                    </ul>
                </div>
            </div>
            <div class="welcome-bottom-group">
                <div class="highest-reached" id="highest-reached-display">
                    <span class="highest-label">Highest Reached: </span>
                    <span class="highest-value" id="highest-reached-value">—</span>
                </div>
                <button id="start-btn">Start</button>
            </div>
        </div>
        
        <div id="debug-overlay">
            <div>Velocity: <span id="debug-vel">0, 0</span></div>
            <div>State: <span id="debug-state">edit</span></div>
        </div>
        <div id="game-overlay">
            <div class="overlay-card">
                <h1 id="overlay-text">SUCCESS!</h1>
                <div class="level-complete" id="level-complete-text">Level 1 Complete</div>
                <div id="safari-timing-info"></div>
                <div class="star-rating">
                    <span class="star" id="star1">★</span>
                    <span class="star" id="star2">★</span>
                    <span class="star" id="star3">★</span>
                </div>
                <div>
                    <button class="overlay-btn" id="next-level-btn">Next Level</button>
                    <button class="overlay-btn" id="retry-btn">Main Menu</button>
                </div>
            </div>
        </div>
        
        <!-- Powerup Overlay (dims screen except powerup area) -->
        <div id="powerup-overlay"></div>
        
        <!-- T Powerup Popover -->
        <div id="powerup-popover">
            <h3>Extend the ball trajectory.</h3>
            <button id="powerup-use-btn">Use</button>
        </div>
        
        <!-- R Powerup Popover -->
        <div id="r-powerup-popover">
            <h3>Remove an object.</h3>
            <button id="r-powerup-use-btn">Use</button>
        </div>
        
        <!-- E Powerup Popover -->
        <div id="e-powerup-popover">
            <h3>Widen the basket.</h3>
            <button id="e-powerup-use-btn">Use</button>
        </div>
        
        <!-- Remove Selection Overlay (for object selection mode) -->
        <div id="remove-selection-overlay"></div>
    </div>

    <script>
        /*
         * ========================================
         * LAYOUT PIXEL VALUES (all configurable)
         * ========================================
         * 
         * LEVEL DATA AREA (top):
         *   - Height: 75px
         *   - Padding from edges: 12px
         *   - Box corner radius: 8px
         * 
         * MOVES BOX (top-left):
         *   - Width: 75px
         *   - Height: 55px
         *   - X position: 12px from left
         *   - Y position: 10px from top
         *   - "Lives" font size: 11px
         *   - Number font size: 24px
         *   - Separator line Y offset: 22px from box top
         * 
         * LEVEL SPECS BOX (top-right):
         *   - Width: 75px
         *   - Height: 55px
         *   - X position: 12px from right edge
         *   - Y position: 10px from top
         *   - Text font size: 9px (auto-reduced if needed)
         * 
         * LEVEL DISPLAY (center):
         *   - Font size: 26px
         *   - Y position: aligned with box centers
         * 
         * BALL LINE:
         *   - Y position: levelDataAreaHeight + 30px = 105px from top
         * 
         * PIECE AREA:
         *   - Height: 90px
         *   - Margin from edges: 15px
         *   - Position: 15px above basket line
         *   - Corner radius: 10px (dashed)
         * 
         * BASKET LINE:
         *   - Y position: canvas height - powerupAreaHeight - bottomControlsHeight - 5px
         * 
         * BOTTOM CONTROLS AREA:
         *   - Height: 55px
         *   - Padding: 8px
         * 
         * ANGLE BOX (bottom-left):
         *   - Width: (canvas width - 40px) / 2 - 5px
         *   - Height: 40px
         *   - X position: 15px from left
         *   - Corner radius: 10px
         * 
         * SUBMIT BUTTON (bottom-right):
         *   - Width: same as angle box
         *   - Height: 40px
         *   - Corner radius: 10px
         * 
         * POWERUP AREA (bottom):
         *   - Height: 60px
         *   - Button size: 42x42px
         *   - Button corner radius: 8px
         *   - Spacing: evenly distributed
         * 
         * DEGREE SWIPE SENSITIVITY:
         *   - 1 pixel swipe = 0.1 degrees (very fine control)
         */

        // ========================================
        // SAFARI DETECTION & TRANSITION DEBUG
        // Safari GPU compositor stalls on backdrop-filter blur
        // over continuously-updating canvas during transitions
        // ========================================
        const DEBUG_TRANSITIONS = false;  // Set true to see timing logs
        const DEBUG_ONEWAY = false;       // One-way collision debug
        
        const IS_SAFARI = (() => {
            const ua = navigator.userAgent;
            // Match Safari but exclude Chrome, Firefox, Edge, Opera on iOS
            const isSafari = /safari/i.test(ua) && 
                             !/chrome|chromium|crios|fxios|edgios|opera|opr/i.test(ua);
            if (isSafari) {
                document.body.classList.add('safari');
                console.log('[SAFARI] Detected - performance optimizations enabled');
            }
            return isSafari;
        })();

        const ShapeTypeEnum = {
            TRIANGLE_LEFT: 'triangle_left',
            TRIANGLE_RIGHT: 'triangle_right',
            LINE: 'line',
            HALF_CIRCLE: 'half_circle',
            DIAMOND: 'diamond',
            OCTAGON: 'octagon',
            TRAPEZOID: 'trapezoid',
            ARROWHEAD: 'arrowhead',
            BOOMERANG: 'boomerang',
            HALF_PIPE: 'half_pipe',
            SAWTOOTH_RAMP: 'sawtooth_ramp'
        };

        // ========================================
        // COLOR SKINS - Choose your palette
        // ========================================
        const SKINS = {
            arcadeDark: {
                name: 'Arcade Dark',
                // Core palette
                primary: '#22D3EE',      // Cyan - unified selection color
                primaryLight: '#67E8F9',
                primaryDark: '#0891B2',
                secondary: '#22D3EE',    // Same cyan for consistency
                secondaryLight: '#67E8F9',
                accent: '#FBBF24',       // Amber accent
                accentLight: '#FCD34D',
                danger: '#F87171',
                dangerLight: '#FCA5A5',
                success: '#4ADE80',
                ink: '#0F172A',
                
                // Background - LIGHTER playfield for better contrast
                bgGradientStart: '#3D4A5F',
                bgGradientMid: '#475569',
                bgGradientEnd: '#3D4A5F',
                bgPattern: 'rgba(99, 102, 241, 0.025)',
                
                // Panels - semi-dark glass
                panelTopStart: 'rgba(51, 65, 85, 0.92)',
                panelTopEnd: 'rgba(51, 65, 85, 0.85)',
                panelTopStroke: 'rgba(255, 255, 255, 0.12)',
                panelBottomStart: 'rgba(51, 65, 85, 0.92)',
                panelBottomEnd: 'rgba(51, 65, 85, 0.85)',
                panelBottomStroke: 'rgba(255, 255, 255, 0.12)',
                panelPowerupStart: 'rgba(51, 65, 85, 0.94)',
                panelPowerupEnd: 'rgba(51, 65, 85, 0.88)',
                
                // HUD Pills - more opaque for contrast
                movesPillStart: 'rgba(51, 65, 85, 0.95)',
                movesPillEnd: 'rgba(51, 65, 85, 0.9)',
                movesPillStroke: 'rgba(255, 255, 255, 0.18)',
                specsPillStart: 'rgba(51, 65, 85, 0.95)',
                specsPillEnd: 'rgba(51, 65, 85, 0.9)',
                specsPillStroke: 'rgba(255, 255, 255, 0.18)',
                
                // Lives urgency
                movesGoodStart: 'rgba(34, 197, 94, 0.3)',
                movesGoodEnd: 'rgba(34, 197, 94, 0.2)',
                movesGoodText: '#4ADE80',
                movesGoodGlow: 'rgba(34, 197, 94, 0.5)',
                movesWarnStart: 'rgba(251, 191, 36, 0.3)',
                movesWarnEnd: 'rgba(251, 191, 36, 0.2)',
                movesWarnText: '#FBBF24',
                movesWarnGlow: 'rgba(251, 191, 36, 0.5)',
                movesLowStart: 'rgba(248, 113, 113, 0.35)',
                movesLowEnd: 'rgba(248, 113, 113, 0.25)',
                movesLowText: '#F87171',
                movesLowGlow: 'rgba(248, 113, 113, 0.6)',
                
                // Buttons - Submit uses LIME GREEN
                submitStart: '#A3E635',
                submitEnd: '#65A30D',
                submitGlow: 'rgba(163, 230, 53, 0.6)',
                submitDisabledStart: 'rgba(100, 116, 139, 0.7)',
                submitDisabledEnd: 'rgba(100, 116, 139, 0.5)',
                
                // Angle chip - CYAN (same as shape selection)
                angleChipStart: 'rgba(71, 85, 105, 0.9)',
                angleChipEnd: 'rgba(71, 85, 105, 0.8)',
                angleChipStroke: 'rgba(255, 255, 255, 0.15)',
                angleChipActiveStart: 'rgba(34, 211, 238, 0.25)',
                angleChipActiveEnd: 'rgba(34, 211, 238, 0.15)',
                angleChipActiveStroke: '#22D3EE',
                angleChipActiveText: '#22D3EE',
                
                // Powerups
                powerup1Start: 'rgba(34, 211, 238, 0.18)',
                powerup1End: 'rgba(34, 211, 238, 0.1)',
                powerup1Stroke: 'rgba(34, 211, 238, 0.4)',
                powerup2Start: 'rgba(251, 113, 133, 0.18)',
                powerup2End: 'rgba(251, 113, 133, 0.1)',
                powerup2Stroke: 'rgba(251, 113, 133, 0.4)',
                powerup3Start: 'rgba(251, 191, 36, 0.18)',
                powerup3End: 'rgba(251, 191, 36, 0.1)',
                powerup3Stroke: 'rgba(251, 191, 36, 0.4)',
                
                // Ball - warm amber/orange
                ballFillStart: '#FDE68A',
                ballFillEnd: '#FBBF24',
                ballStroke: '#F59E0B',
                
                // Basket - GREEN (different from submit amber and selection cyan)
                basketFill: 'rgba(74, 222, 128, 0.18)',
                basketStroke: '#4ADE80',
                basketRim: '#22C55E',
                basketLid: '#F87171',
                basketLidGlow: 'rgba(248, 113, 113, 0.5)',
                
                // Shapes - neutral gray unselected
                shapeNeutralFill: 'rgba(148, 163, 184, 0.25)',
                shapeNeutralStroke: 'rgba(203, 213, 225, 0.8)',
                shapeNeutralGlow: 'rgba(203, 213, 225, 0.3)',
                
                // Shape SELECTION - CYAN (same as angle chip)
                shapeSelectedAccent: '#22D3EE',
                shapeSelectedFill: 'rgba(34, 211, 238, 0.25)',
                shapeSelectedStroke: '#67E8F9',
                shapeSelectedGlow: 'rgba(34, 211, 238, 0.6)',
                
                // Lines
                spawnLine: 'rgba(203, 213, 225, 0.35)',
                basketLine: 'rgba(74, 222, 128, 0.4)',
                pieceAreaStroke: 'rgba(203, 213, 225, 0.3)',
                
                // Trajectory - cyan to match selection
                trajectoryStart: 'rgba(34, 211, 238, 0.6)',
                trajectoryEnd: 'rgba(34, 211, 238, 0.1)',
                trajectoryTick: 'rgba(34, 211, 238, 0.5)',
                trajectoryImpact: '#FBBF24',
                trajectoryImpactGlow: 'rgba(251, 191, 36, 0.5)',
                
                // Trail & VFX
                trailColor: '#FBBF24',
                trailColorFast: '#F87171',
                trailGlow: 'rgba(251, 191, 36, 0.6)',
                particleColors: ['#FBBF24', '#F87171', '#22D3EE', '#4ADE80', '#FFFFFF'],
                confettiColors: ['#22D3EE', '#FBBF24', '#4ADE80', '#F87171', '#67E8F9', '#FCD34D'],
                shapeHitHighlight: '#FBBF24',
                swooshColor: 'rgba(34, 211, 238, 0.5)',
                
                // Text
                textPrimary: '#F1F5F9',
                textSecondary: '#CBD5E1',
                textMuted: '#94A3B8',
                textLight: '#64748B',
                textOnPrimary: '#FFFFFF',
            },
            
            candyPastel: {
                name: 'Candy Pastel',
                // Core palette
                primary: '#7C5CFF',
                primaryLight: '#9D85FF',
                primaryDark: '#5B3FD9',
                secondary: '#2ED3B7',
                secondaryLight: '#5EEBD4',
                accent: '#FFB020',
                accentLight: '#FFCC66',
                danger: '#FF4D6D',
                dangerLight: '#FF7A93',
                success: '#2ED3B7',
                ink: '#0F172A',
                
                // Background
                bgGradientStart: '#F5F0FF',
                bgGradientMid: '#F0FAFF',
                bgGradientEnd: '#FFF5F8',
                bgPattern: 'rgba(124, 92, 255, 0.04)',
                
                // Panels
                panelTopStart: 'rgba(245, 240, 255, 0.95)',
                panelTopEnd: 'rgba(240, 248, 255, 0.92)',
                panelTopStroke: 'rgba(124, 92, 255, 0.15)',
                panelBottomStart: 'rgba(240, 255, 250, 0.95)',
                panelBottomEnd: 'rgba(248, 250, 255, 0.92)',
                panelBottomStroke: 'rgba(46, 211, 183, 0.15)',
                panelPowerupStart: 'rgba(255, 245, 248, 0.95)',
                panelPowerupEnd: 'rgba(255, 240, 245, 0.92)',
                
                // HUD Pills
                movesPillStart: '#FFFFFF',
                movesPillEnd: '#F8F5FF',
                movesPillStroke: 'rgba(124, 92, 255, 0.2)',
                specsPillStart: '#FFFFFF',
                specsPillEnd: '#F0FFF8',
                specsPillStroke: 'rgba(46, 211, 183, 0.2)',
                
                // Lives urgency
                movesGoodStart: '#E8FFF5',
                movesGoodEnd: '#D0FFF0',
                movesGoodText: '#0F9B7A',
                movesGoodGlow: 'rgba(46, 211, 183, 0.3)',
                movesWarnStart: '#FFF8E8',
                movesWarnEnd: '#FFF0D0',
                movesWarnText: '#B87A00',
                movesWarnGlow: 'rgba(255, 176, 32, 0.4)',
                movesLowStart: '#FFE8EE',
                movesLowEnd: '#FFD0DD',
                movesLowText: '#D62B4C',
                movesLowGlow: 'rgba(255, 77, 109, 0.5)',
                
                // Buttons
                submitStart: '#7C5CFF',
                submitEnd: '#5B3FD9',
                submitGlow: 'rgba(124, 92, 255, 0.5)',
                submitDisabledStart: '#E8E5F5',
                submitDisabledEnd: '#D8D5E8',
                angleChipStart: '#F0FFF8',
                angleChipEnd: '#E8FFF5',
                angleChipStroke: 'rgba(46, 211, 183, 0.3)',
                angleChipActiveStart: '#E8FFF5',
                angleChipActiveEnd: '#D0FFF0',
                angleChipActiveStroke: '#2ED3B7',
                
                // Powerups
                powerup1Start: '#F0FFF8',
                powerup1End: '#D0FFF0',
                powerup1Stroke: 'rgba(46, 211, 183, 0.3)',
                powerup2Start: '#FFF0F5',
                powerup2End: '#FFE0EB',
                powerup2Stroke: 'rgba(255, 77, 109, 0.3)',
                powerup3Start: '#FFF8E8',
                powerup3End: '#FFF0D0',
                powerup3Stroke: 'rgba(255, 176, 32, 0.3)',
                
                // Game elements
                ballFillStart: '#FFE8C8',
                ballFillEnd: '#FFD4A3',
                ballStroke: '#FFB866',
                basketFill: 'rgba(124, 92, 255, 0.08)',
                basketStroke: '#7C5CFF',
                basketRim: '#7C5CFF',
                basketLid: '#FF4D6D',
                basketLidGlow: 'rgba(255, 77, 109, 0.4)',
                
                // Shapes
                shapeColors: [
                    { fill: 'rgba(124, 92, 255, 0.12)', stroke: '#7C5CFF', glow: 'rgba(124, 92, 255, 0.3)' },
                    { fill: 'rgba(46, 211, 183, 0.12)', stroke: '#2ED3B7', glow: 'rgba(46, 211, 183, 0.3)' },
                    { fill: 'rgba(255, 176, 32, 0.12)', stroke: '#FFB020', glow: 'rgba(255, 176, 32, 0.3)' },
                    { fill: 'rgba(255, 77, 109, 0.12)', stroke: '#FF4D6D', glow: 'rgba(255, 77, 109, 0.3)' },
                ],
                shapeSelected: '#7C5CFF',
                
                // Lines
                spawnLine: 'rgba(124, 92, 255, 0.25)',
                basketLine: 'rgba(46, 211, 183, 0.25)',
                pieceAreaStroke: 'rgba(124, 92, 255, 0.2)',
                
                // Trajectory
                trajectoryStart: 'rgba(124, 92, 255, 0.6)',
                trajectoryEnd: 'rgba(124, 92, 255, 0.08)',
                trajectoryTick: 'rgba(124, 92, 255, 0.5)',
                trajectoryImpact: '#FFB020',
                trajectoryImpactGlow: 'rgba(255, 176, 32, 0.4)',
                
                // Trail & VFX
                trailColor: '#FFB020',
                trailColorFast: '#FF4D6D',
                trailGlow: 'rgba(255, 176, 32, 0.6)',
                particleColors: ['#FFB020', '#FF4D6D', '#7C5CFF', '#2ED3B7', '#FFFFFF'],
                confettiColors: ['#7C5CFF', '#2ED3B7', '#FFB020', '#FF4D6D', '#9D85FF', '#5EEBD4'],
                shapeHitHighlight: '#FFB020',
                swooshColor: 'rgba(124, 92, 255, 0.5)',
                
                // Text
                textPrimary: '#0F172A',
                textSecondary: '#475569',
                textMuted: '#94A3B8',
                textLight: '#CBD5E1',
                textOnPrimary: '#FFFFFF',
            },
            
            skyPop: {
                name: 'Sky Pop',
                primary: '#3B82F6',
                primaryLight: '#60A5FA',
                primaryDark: '#2563EB',
                secondary: '#A78BFA',
                secondaryLight: '#C4B5FD',
                accent: '#FB7185',
                accentLight: '#FDA4AF',
                danger: '#EF4444',
                dangerLight: '#F87171',
                success: '#22C55E',
                ink: '#0F172A',
                bgGradientStart: '#EFF6FF',
                bgGradientMid: '#F5F3FF',
                bgGradientEnd: '#FFF1F2',
                bgPattern: 'rgba(59, 130, 246, 0.04)',
                panelTopStart: 'rgba(239, 246, 255, 0.95)',
                panelTopEnd: 'rgba(245, 243, 255, 0.92)',
                panelTopStroke: 'rgba(59, 130, 246, 0.15)',
                panelBottomStart: 'rgba(245, 243, 255, 0.95)',
                panelBottomEnd: 'rgba(255, 241, 242, 0.92)',
                panelBottomStroke: 'rgba(167, 139, 250, 0.15)',
                panelPowerupStart: 'rgba(255, 241, 242, 0.95)',
                panelPowerupEnd: 'rgba(254, 226, 226, 0.92)',
                movesPillStart: '#FFFFFF',
                movesPillEnd: '#EFF6FF',
                movesPillStroke: 'rgba(59, 130, 246, 0.2)',
                specsPillStart: '#FFFFFF',
                specsPillEnd: '#F5F3FF',
                specsPillStroke: 'rgba(167, 139, 250, 0.2)',
                movesGoodStart: '#DCFCE7',
                movesGoodEnd: '#BBF7D0',
                movesGoodText: '#166534',
                movesGoodGlow: 'rgba(34, 197, 94, 0.3)',
                movesWarnStart: '#FEF9C3',
                movesWarnEnd: '#FEF08A',
                movesWarnText: '#A16207',
                movesWarnGlow: 'rgba(234, 179, 8, 0.4)',
                movesLowStart: '#FEE2E2',
                movesLowEnd: '#FECACA',
                movesLowText: '#DC2626',
                movesLowGlow: 'rgba(239, 68, 68, 0.5)',
                submitStart: '#3B82F6',
                submitEnd: '#2563EB',
                submitGlow: 'rgba(59, 130, 246, 0.5)',
                submitDisabledStart: '#E0E7FF',
                submitDisabledEnd: '#C7D2FE',
                angleChipStart: '#F5F3FF',
                angleChipEnd: '#EDE9FE',
                angleChipStroke: 'rgba(167, 139, 250, 0.3)',
                angleChipActiveStart: '#EDE9FE',
                angleChipActiveEnd: '#DDD6FE',
                angleChipActiveStroke: '#A78BFA',
                powerup1Start: '#DBEAFE',
                powerup1End: '#BFDBFE',
                powerup1Stroke: 'rgba(59, 130, 246, 0.3)',
                powerup2Start: '#F5F3FF',
                powerup2End: '#EDE9FE',
                powerup2Stroke: 'rgba(167, 139, 250, 0.3)',
                powerup3Start: '#FFE4E6',
                powerup3End: '#FECDD3',
                powerup3Stroke: 'rgba(251, 113, 133, 0.3)',
                ballFillStart: '#FDE68A',
                ballFillEnd: '#FCD34D',
                ballStroke: '#F59E0B',
                basketFill: 'rgba(59, 130, 246, 0.08)',
                basketStroke: '#3B82F6',
                basketRim: '#3B82F6',
                basketLid: '#FB7185',
                basketLidGlow: 'rgba(251, 113, 133, 0.4)',
                shapeColors: [
                    { fill: 'rgba(59, 130, 246, 0.12)', stroke: '#3B82F6', glow: 'rgba(59, 130, 246, 0.3)' },
                    { fill: 'rgba(167, 139, 250, 0.12)', stroke: '#A78BFA', glow: 'rgba(167, 139, 250, 0.3)' },
                    { fill: 'rgba(251, 113, 133, 0.12)', stroke: '#FB7185', glow: 'rgba(251, 113, 133, 0.3)' },
                    { fill: 'rgba(34, 197, 94, 0.12)', stroke: '#22C55E', glow: 'rgba(34, 197, 94, 0.3)' },
                ],
                shapeSelected: '#3B82F6',
                spawnLine: 'rgba(59, 130, 246, 0.25)',
                basketLine: 'rgba(167, 139, 250, 0.25)',
                pieceAreaStroke: 'rgba(59, 130, 246, 0.2)',
                trajectoryStart: 'rgba(59, 130, 246, 0.6)',
                trajectoryEnd: 'rgba(59, 130, 246, 0.08)',
                trajectoryTick: 'rgba(59, 130, 246, 0.5)',
                trajectoryImpact: '#FB7185',
                trajectoryImpactGlow: 'rgba(251, 113, 133, 0.4)',
                trailColor: '#FB7185',
                trailColorFast: '#EF4444',
                trailGlow: 'rgba(251, 113, 133, 0.6)',
                particleColors: ['#3B82F6', '#A78BFA', '#FB7185', '#22C55E', '#FFFFFF'],
                confettiColors: ['#3B82F6', '#A78BFA', '#FB7185', '#22C55E', '#60A5FA', '#FDA4AF'],
                shapeHitHighlight: '#FB7185',
                swooshColor: 'rgba(59, 130, 246, 0.5)',
                textPrimary: '#0F172A',
                textSecondary: '#475569',
                textMuted: '#94A3B8',
                textLight: '#CBD5E1',
                textOnPrimary: '#FFFFFF',
            },
            
            sunsetSoda: {
                name: 'Sunset Soda',
                primary: '#FF6B6B',
                primaryLight: '#FF8A8A',
                primaryDark: '#E85555',
                secondary: '#4D96FF',
                secondaryLight: '#70ABFF',
                accent: '#FFD93D',
                accentLight: '#FFE566',
                danger: '#FF4757',
                dangerLight: '#FF6B7A',
                success: '#2ED573',
                ink: '#2D3436',
                bgGradientStart: '#FFF5F5',
                bgGradientMid: '#FFF9E6',
                bgGradientEnd: '#F0F7FF',
                bgPattern: 'rgba(255, 107, 107, 0.04)',
                panelTopStart: 'rgba(255, 245, 245, 0.95)',
                panelTopEnd: 'rgba(255, 249, 230, 0.92)',
                panelTopStroke: 'rgba(255, 107, 107, 0.15)',
                panelBottomStart: 'rgba(240, 247, 255, 0.95)',
                panelBottomEnd: 'rgba(230, 242, 255, 0.92)',
                panelBottomStroke: 'rgba(77, 150, 255, 0.15)',
                panelPowerupStart: 'rgba(255, 249, 230, 0.95)',
                panelPowerupEnd: 'rgba(255, 245, 200, 0.92)',
                movesPillStart: '#FFFFFF',
                movesPillEnd: '#FFF5F5',
                movesPillStroke: 'rgba(255, 107, 107, 0.2)',
                specsPillStart: '#FFFFFF',
                specsPillEnd: '#F0F7FF',
                specsPillStroke: 'rgba(77, 150, 255, 0.2)',
                movesGoodStart: '#E8FFF0',
                movesGoodEnd: '#D0FFE5',
                movesGoodText: '#1E9B5A',
                movesGoodGlow: 'rgba(46, 213, 115, 0.3)',
                movesWarnStart: '#FFF9E6',
                movesWarnEnd: '#FFF2CC',
                movesWarnText: '#CC9900',
                movesWarnGlow: 'rgba(255, 217, 61, 0.4)',
                movesLowStart: '#FFE8EA',
                movesLowEnd: '#FFD0D5',
                movesLowText: '#E84555',
                movesLowGlow: 'rgba(255, 71, 87, 0.5)',
                submitStart: '#FF6B6B',
                submitEnd: '#E85555',
                submitGlow: 'rgba(255, 107, 107, 0.5)',
                submitDisabledStart: '#FFE5E5',
                submitDisabledEnd: '#FFD5D5',
                angleChipStart: '#F0F7FF',
                angleChipEnd: '#E0EFFF',
                angleChipStroke: 'rgba(77, 150, 255, 0.3)',
                angleChipActiveStart: '#E0EFFF',
                angleChipActiveEnd: '#D0E7FF',
                angleChipActiveStroke: '#4D96FF',
                powerup1Start: '#FFE8EA',
                powerup1End: '#FFD5D8',
                powerup1Stroke: 'rgba(255, 107, 107, 0.3)',
                powerup2Start: '#E8F4FF',
                powerup2End: '#D0E8FF',
                powerup2Stroke: 'rgba(77, 150, 255, 0.3)',
                powerup3Start: '#FFF9E6',
                powerup3End: '#FFF2CC',
                powerup3Stroke: 'rgba(255, 217, 61, 0.3)',
                ballFillStart: '#FFE8C8',
                ballFillEnd: '#FFD4A3',
                ballStroke: '#FFB866',
                basketFill: 'rgba(255, 107, 107, 0.08)',
                basketStroke: '#FF6B6B',
                basketRim: '#FF6B6B',
                basketLid: '#4D96FF',
                basketLidGlow: 'rgba(77, 150, 255, 0.4)',
                shapeColors: [
                    { fill: 'rgba(255, 107, 107, 0.12)', stroke: '#FF6B6B', glow: 'rgba(255, 107, 107, 0.3)' },
                    { fill: 'rgba(77, 150, 255, 0.12)', stroke: '#4D96FF', glow: 'rgba(77, 150, 255, 0.3)' },
                    { fill: 'rgba(255, 217, 61, 0.12)', stroke: '#FFD93D', glow: 'rgba(255, 217, 61, 0.3)' },
                    { fill: 'rgba(46, 213, 115, 0.12)', stroke: '#2ED573', glow: 'rgba(46, 213, 115, 0.3)' },
                ],
                shapeSelected: '#FF6B6B',
                spawnLine: 'rgba(255, 107, 107, 0.25)',
                basketLine: 'rgba(77, 150, 255, 0.25)',
                pieceAreaStroke: 'rgba(255, 107, 107, 0.2)',
                trajectoryStart: 'rgba(77, 150, 255, 0.6)',
                trajectoryEnd: 'rgba(77, 150, 255, 0.08)',
                trajectoryTick: 'rgba(77, 150, 255, 0.5)',
                trajectoryImpact: '#FFD93D',
                trajectoryImpactGlow: 'rgba(255, 217, 61, 0.4)',
                trailColor: '#FFD93D',
                trailColorFast: '#FF6B6B',
                trailGlow: 'rgba(255, 217, 61, 0.6)',
                particleColors: ['#FF6B6B', '#4D96FF', '#FFD93D', '#2ED573', '#FFFFFF'],
                confettiColors: ['#FF6B6B', '#4D96FF', '#FFD93D', '#2ED573', '#FF8A8A', '#70ABFF'],
                shapeHitHighlight: '#FFD93D',
                swooshColor: 'rgba(77, 150, 255, 0.5)',
                textPrimary: '#2D3436',
                textSecondary: '#636E72',
                textMuted: '#B2BEC3',
                textLight: '#DFE6E9',
                textOnPrimary: '#FFFFFF',
            }
        };

        // ========================================
        // ACTIVE SKIN SELECTION
        // ========================================
        const ACTIVE_SKIN = 'arcadeDark'; // Options: 'arcadeDark', 'candyPastel', 'skyPop', 'sunsetSoda'
        const SKIN = SKINS[ACTIVE_SKIN];

        // ========================================
        // THEME - Built from active skin
        // ========================================
        const THEME = {
            // Core colors from skin
            ...SKIN,
            
            // One-way surface highlight color (vivid magenta)
            oneWayHighlight: '#FF6B9D',
            oneWayGlow: 'rgba(255, 107, 157, 0.6)',
            
            // Computed/legacy values for compatibility
            glassBackground: 'rgba(30, 41, 59, 0.85)',
            glassBorder: 'rgba(255, 255, 255, 0.1)',
            glassBackgroundSolid: 'rgba(51, 65, 85, 0.95)',
            
            // Shadows
            shadowSoft: 'rgba(0, 0, 0, 0.25)',
            shadowMedium: 'rgba(0, 0, 0, 0.35)',
            shadowGlow: SKIN.submitGlow,
            shadowSuccess: SKIN.submitGlow,
            
            // Button colors
            buttonDisabled: SKIN.submitDisabledStart,
            buttonDisabledText: SKIN.textMuted,
            
            // Success colors for hit checkmarks
            successLight: SKIN.success,
            success: SKIN.success,
            
            // Shape colors - NEUTRAL for unselected
            shapeStroke: SKIN.shapeNeutralStroke || 'rgba(148, 163, 184, 0.9)',
            shapeFill: SKIN.shapeNeutralFill || 'rgba(100, 116, 139, 0.35)',
            shapeGlow: SKIN.shapeNeutralGlow || 'rgba(148, 163, 184, 0.4)',
            
            // Shape SELECTED - CYAN (matches angle chip)
            shapeSelected: SKIN.shapeSelectedStroke || SKIN.secondary,
            shapeSelectedFill: SKIN.shapeSelectedFill || 'rgba(34, 211, 238, 0.2)',
            shapeSelectedGlow: SKIN.shapeSelectedGlow || 'rgba(34, 211, 238, 0.6)',
            shapeSelectedAccent: SKIN.shapeSelectedAccent || SKIN.secondary,
        };

        // ========================================
        // DEBUG FLAGS
        // ========================================
        // DEBUG_ONEWAY defined at script start (~line 894)
        
        // ========================================
        // ANIMATION EASING VALUES
        // ========================================
        const ANIM = {
            buttonPressScale: 0.96,
            buttonHoverScale: 1.02,
            hudPopDuration: 0.3,
            glowPulseSpeed: 2.5,
            transitionSpeed: 0.15,
            
            // Ball trail settings
            trailMaxPoints: 30,           // Circular buffer size
            trailMinDistance: 3,          // Min pixels between samples
            trailSpeedThreshold: 50,      // Min speed to show trail
            trailFadeSpeed: 4,            // How fast trail fades
            trailHighSpeedThreshold: 400, // Speed for glow effect
            
            // Squash/stretch settings
            squashAmount: 0.25,           // Max squash (25% compression)
            squashDecay: 12,              // How fast squash recovers
            
            // Collision particles
            particleCountMin: 6,
            particleCountMax: 12,
            particleLifetimeMin: 0.25,
            particleLifetimeMax: 0.5,
            particleSpeedMin: 80,
            particleSpeedMax: 200,
            particleSizeMin: 2,
            particleSizeMax: 5,
            
            // Shape hit feedback
            shapeHitScale: 1.15,
            shapeHitScaleDecay: 8,
            shapeHighlightDuration: 0.3,
            
            // Basket animation
            lidOpenSpeed: 12,
            lidBounce: 0.3,
            successPulseScale: 1.2,
            basketPulseDuration: 0.3,
            confettiCount: 30,
            confettiLifetime: 1.5,
            
            // Screen shake
            shakeThreshold: 300,
            shakeIntensity: 4,
            shakeDuration: 0.15,
            
            // Replay swoosh
            swooshDuration: 0.4,
            
            // Trajectory preview
            trajectoryDotSpacing: 8,
            trajectoryTickSpacing: 40,
            trajectoryTickSize: 6,
            trajectoryPulseSpeed: 3,
            
            // HUD transitions
            hudStateTransitionSpeed: 6,
            hudStateOffset: 8,
            submitPopScale: 1.08,
            submitPopDuration: 0.2,
        };

        // ========================================
        // CONFIGURABLE LAYOUT VALUES (in pixels)
        // ========================================
        const LAYOUT = {
            // === LEVEL DATA AREA (top red bar) ===
            levelDataAreaHeight: 75,        // Total height of the top area containing moves, level, specs
            levelDataAreaPadding: 12,       // General padding from screen edges
            
            // === MOVES BOX (top-left corner) ===
            movesBoxWidth: 100,             // Width of the moves display box
            movesBoxHeight: 55,             // Height of the moves display box
            movesBoxX: 12,                  // Distance from left edge of screen
            movesBoxY: 10,                  // Distance from top edge of screen
            movesLabelFontSize: 11,         // Font size for "Moves" text
            movesNumberFontSize: 24,        // Font size for the move count number
            movesSeparatorY: 22,            // Y position of horizontal line inside box (from box top)
            
            // === LEVEL SPECS BOX (top-right corner) ===
            specsBoxWidth: 100,             // Width of the gravity/rebound display box
            specsBoxHeight: 55,             // Height of the gravity/rebound display box
            specsBoxMarginRight: 12,        // Distance from right edge of screen
            specsBoxY: 10,                  // Distance from top edge of screen
            specsFontSize: 11,              // Font size for "Normal Gravity" / "Normal Rebound" text
            
            // === LEVEL DISPLAY (top-center) ===
            levelFontSize: 26,              // Font size for "Level X" text
            
            // === BALL LINE (where ball spawns) ===
            ballLineOffsetFromTop: 60,      // Distance below level data area to ball spawn line
            
            // === PIECE AREA (where shapes start) ===
            pieceAreaHeight: 90,            // Height of the dashed piece area box
            pieceAreaMargin: 15,            // Left/right margin from screen edges
            pieceAreaAboveBasket: 70,       // Gap between piece area bottom and basket line
            
            // === BASKET LINE OFFSET ===
            basketLineExtraOffset: 120,     // Extra pixels to move basket line higher
            
            // === BOTTOM CONTROLS (angle box + submit button) - separate area just above powerups ===
            bottomControlsHeight: 105,      // Total height: 25px top padding + 55px button + 25px bottom padding = 105px
            bottomControlsPadding: 25,      // Padding from top AND bottom of controls area to buttons
            controlBoxHeight: 55,           // Height of angle box and submit button
            controlBoxMargin: 25,           // Left/right margin from screen edges
            controlBoxGap: 35,              // Gap between angle box and submit button
            controlBoxFontSize: 20,         // Font size for SUBMIT and degree text
            
            // === POWERUP AREA (bottom bar) ===
            powerupAreaHeight: 60,          // Total height of the powerup buttons area
            powerupButtonSize: 42,          // Width and height of each powerup button (square)
            
            // === CORNER RADII (for rounded corners) ===
            boxCornerRadius: 8,             // Corner radius for moves box, specs box, powerup buttons
            controlCornerRadius: 10,        // Corner radius for angle box and submit button
            pieceAreaCornerRadius: 10,      // Corner radius for the dashed piece area
            
            // === INTERACTION SENSITIVITY ===
            degreeSwipeSensitivity: 0.1     // Degrees of rotation per pixel swiped (lower = finer control)
                                            // 0.1 means swiping 10 pixels = 1 degree rotation
                                            // 0.5 means swiping 2 pixels = 1 degree rotation
        };

        // ========================================
        // LEVEL SPECS - Gravity & Rebound Presets
        // ========================================
        const BASE_GRAVITY = 1500;  // Base gravity constant
        
        const GRAVITY_PRESETS = {
            'Low':    { multiplier: 0.70, color: '#4ADE80' },  // Green - easier
            'Normal': { multiplier: 1.00, color: '#FFFFFF' },  // White - neutral
            'High':   { multiplier: 1.30, color: '#F87171' }   // Red - harder
        };
        
        const REBOUND_PRESETS = {
            'Soft':   { restitution: 0.55, friction: 0.82, color: '#4ADE80' },  // Green - less bouncy
            'Normal': { restitution: 0.75, friction: 0.90, color: '#FFFFFF' },  // White - neutral
            'Bouncy': { restitution: 0.92, friction: 0.94, color: '#F87171' }   // Red - more bouncy
        };
        
        const GRAVITY_NAMES = ['Low', 'Normal', 'High'];
        const REBOUND_NAMES = ['Soft', 'Normal', 'Bouncy'];

        // ========================================
        // SHAPE CATEGORIES (Normal vs Odd)
        // ========================================
        const NORMAL_SHAPES = [
            ShapeTypeEnum.TRIANGLE_LEFT,
            ShapeTypeEnum.TRIANGLE_RIGHT,
            ShapeTypeEnum.LINE,
            ShapeTypeEnum.HALF_CIRCLE,
            ShapeTypeEnum.TRAPEZOID
        ];
        
        const ODD_SHAPES = [
            ShapeTypeEnum.DIAMOND,
            ShapeTypeEnum.OCTAGON,
            ShapeTypeEnum.ARROWHEAD,
            ShapeTypeEnum.BOOMERANG,
            ShapeTypeEnum.HALF_PIPE,
            ShapeTypeEnum.SAWTOOTH_RAMP
        ];

        // ========================================
        // DIFFICULTY TIERS for Specs (LEGACY - kept for fallback)
        // ========================================
        const SPECS_TIER = {
            STABLE: 'stable',
            MODERATE: 'moderate', 
            WILD: 'wild'
        };
        
        // Allowed spec combos per tier [gravity, rebound]
        const STABLE_COMBOS = [
            ['Normal', 'Normal'],
            ['Low', 'Normal'],
            ['Normal', 'Soft']
        ];
        
        const MODERATE_COMBOS = [
            ['Normal', 'Normal'],
            ['Low', 'Normal'],
            ['Normal', 'Soft'],
            ['Low', 'Soft'],
            ['High', 'Normal'],
            ['Normal', 'Bouncy']
            // Excluded: High+Bouncy, High+Soft, Low+Bouncy
        ];
        
        // Wild = all 9 combos
        const WILD_COMBOS = [];
        for (const g of GRAVITY_NAMES) {
            for (const r of REBOUND_NAMES) {
                WILD_COMBOS.push([g, r]);
            }
        }

        // ========================================
        // DETERMINISTIC LEVEL DATA (CSV-based)
        // ========================================
        
        // Object ID to ShapeTypeEnum mapping
        const OBJECT_ID_MAP = {
            1: ShapeTypeEnum.TRIANGLE_LEFT,
            2: ShapeTypeEnum.TRIANGLE_RIGHT,
            3: ShapeTypeEnum.LINE,
            4: ShapeTypeEnum.HALF_CIRCLE,
            5: ShapeTypeEnum.TRAPEZOID,
            6: ShapeTypeEnum.DIAMOND,
            7: ShapeTypeEnum.OCTAGON,
            8: ShapeTypeEnum.ARROWHEAD,
            9: ShapeTypeEnum.BOOMERANG,
            10: ShapeTypeEnum.HALF_PIPE,
            11: ShapeTypeEnum.SAWTOOTH_RAMP
        };
        
        // One-way eligibility per shape (LINE is not eligible)
        const ONEWAY_ELIGIBLE = {
            1: true,   // TRIANGLE_LEFT
            2: true,   // TRIANGLE_RIGHT
            3: false,  // LINE - never one-way
            4: true,   // HALF_CIRCLE
            5: true,   // TRAPEZOID
            6: true,   // DIAMOND
            7: true,   // OCTAGON
            8: true,   // ARROWHEAD
            9: true,   // BOOMERANG
            10: true,  // HALF_PIPE
            11: true   // SAWTOOTH_RAMP
        };
        
        // Embedded CSV level data
        const LEVEL_CSV_DATA = `level,object count,objects,oneway object(s),to apply oneway,gravity,rebound
1,3,"1,2,3",0,,normal,normal
2,3,"1,4,2",0,,normal,normal
3,3,"3,5,1",0,,normal,normal
4,3,"4,6,3",4,4 - 0,normal,normal
5,3,"5,9,10",5,5 - 0,low,normal
6,4,"2,4,11,7",2,2 - 2,normal,low
7,4,"7,8,3,5","5,8","5 - 2 ; 8 - 0,3",high,normal
8,4,"5,1,10,9","1,10","1- 1; 10 - 0,1,2",normal,bouncy
9,4,"4,11,6,3","4,11",4 - 0; 11 - 0,high,bouncy
10,4,"2,8,7,9","2,8,9","2 - 0,2; 8 - 0,3; 9 - 0,1",low,bouncy
11,4,"5,10,3,1","5,10,1","5 - 0,2; 10 - 6,7; 1 - 1",high,low
12,5,"6,11,1,3,4","6,1","6 - 1,3; 1 - 1",normal,low
13,5,"9,7,8,2,5","9,7,8","9 - 3,4,5; 7 - 1,7; 8 - 1,2",low,low
14,5,"10,2,3,4,11","10,2,4,11","10-1; 2-0,2; 4-1; 11 - 0",high,bouncy
15,5,"6,6,4,6,6","6,6,6,6",6-0; 6-1; 6-2; 6-3,high,low
16,5,"4,4,10,4,4","4,4,4,4",4-0; 4-0; 4-0; 4-0,normal,bouncy
17,5,"11,11,5,11,11","11,11,11,11",11-0; 11-1; 11-2; 11-3,low,low
18,5,"9,9,3,9,9","9,9,9,9",9-0; 9-1; 9-2; 9-3,low,normal
19,5,"7,7,7,7,7","7,7,7,7,7",7-0; 7-1; 7-2; 7-3,high,normal
20,5,"11,11,11,11,11","11,11,11,11,11",11-0; 11-0; 11-0; 11-0; 11-0,high,bouncy`;

        // Parse CSV into level data structure
        function parseLevelCSV(csvText) {
            const lines = csvText.trim().split('\n');
            const levels = {};
            
            // Skip header row
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;
                
                // Parse CSV with quoted fields
                const fields = [];
                let current = '';
                let inQuotes = false;
                for (let j = 0; j < line.length; j++) {
                    const char = line[j];
                    if (char === '"') {
                        inQuotes = !inQuotes;
                    } else if (char === ',' && !inQuotes) {
                        fields.push(current.trim());
                        current = '';
                    } else {
                        current += char;
                    }
                }
                fields.push(current.trim());
                
                if (fields.length < 7) {
                    console.warn(`[LEVELDATA] Skipping malformed row ${i}: ${line}`);
                    continue;
                }
                
                const levelNum = parseInt(fields[0]);
                if (isNaN(levelNum)) continue;
                
                const objectCount = parseInt(fields[1]);
                
                // Parse objects list - extract numeric IDs
                const objectsRaw = fields[2].replace(/"/g, '');
                const objectIds = objectsRaw.split(',')
                    .map(s => parseInt(s.trim().split('-')[0]))
                    .filter(n => !isNaN(n));
                
                // Parse one-way objects list
                const onewayRaw = fields[3].replace(/"/g, '');
                let onewayIds = [];
                if (onewayRaw && onewayRaw !== '0' && onewayRaw !== '') {
                    onewayIds = onewayRaw.split(',')
                        .map(s => parseInt(s.trim().split('-')[0]))
                        .filter(n => !isNaN(n));
                }
                
                // Parse one-way side assignments: "5 - 0,2; 8 - 0,3" or "6-0; 6-1; 6-2; 6-3"
                // Each assignment maps to one shape instance in order
                const sidesRaw = fields[4].replace(/"/g, '');
                const onewayAssignments = [];  // Array of {objId, sides[]} in order
                if (sidesRaw && sidesRaw.trim()) {
                    const assignments = sidesRaw.split(';');
                    for (const assign of assignments) {
                        const parts = assign.trim().split('-');
                        if (parts.length >= 2) {
                            const objId = parseInt(parts[0].trim());
                            const sides = parts[1].split(',')
                                .map(s => parseInt(s.trim()))
                                .filter(n => !isNaN(n));
                            if (!isNaN(objId) && sides.length > 0) {
                                onewayAssignments.push({ objId, sides });
                            }
                        }
                    }
                }
                
                // Parse gravity (normalize case)
                let gravity = fields[5].trim().toLowerCase();
                gravity = gravity.charAt(0).toUpperCase() + gravity.slice(1);
                if (!['Low', 'Normal', 'High'].includes(gravity)) {
                    console.warn(`[LEVELDATA] Level ${levelNum}: Invalid gravity "${fields[5]}", defaulting to Normal`);
                    gravity = 'Normal';
                }
                
                // Parse rebound (normalize case, handle "low" -> "Soft")
                let rebound = fields[6].trim().toLowerCase();
                if (rebound === 'low') rebound = 'soft';  // CSV uses "low" for soft
                rebound = rebound.charAt(0).toUpperCase() + rebound.slice(1);
                if (!['Soft', 'Normal', 'Bouncy'].includes(rebound)) {
                    console.warn(`[LEVELDATA] Level ${levelNum}: Invalid rebound "${fields[6]}", defaulting to Normal`);
                    rebound = 'Normal';
                }
                
                levels[levelNum] = {
                    level: levelNum,
                    objectCount,
                    objectIds,
                    onewayIds,
                    onewayAssignments,  // Array of {objId, sides[]} in CSV order
                    gravity,
                    rebound
                };
            }
            
            return levels;
        }
        
        // Parse level data at load time
        const LEVELS_DATA = parseLevelCSV(LEVEL_CSV_DATA);
        
        // Get deterministic level config from CSV
        function getLevelConfigFromCSV(levelNum) {
            const data = LEVELS_DATA[levelNum];
            if (!data) {
                console.warn(`[LEVELDATA] Level ${levelNum} not in CSV, using fallback`);
                return null;
            }
            return data;
        }

        // ========================================
        // LEVEL DIFFICULTY CONFIG (Levels 1-20+)
        // ========================================
        // Target object count per level
        function getTargetObjectCount(levelNum) {
            if (levelNum <= 5) return 3;
            if (levelNum <= 10) return 4;
            return 5;
        }
        
        function getLevelConfig(levelNum) {
            // Clamp to reasonable bounds for formula
            const L = Math.max(1, levelNum);
            
            // Get target total object count for this level
            const targetCount = getTargetObjectCount(L);
            
            let normalCount, oddCount, oneWayCount, specsTier;
            
            if (L <= 3) {
                // Levels 1-3: Introduction, no one-way, stable specs
                // All 3 objects, mostly normal shapes
                normalCount = 3;
                oddCount = 0;
                oneWayCount = 0;
                specsTier = SPECS_TIER.STABLE;
            } else if (L <= 5) {
                // Levels 4-5: Introduce one-way, still 3 objects, stable specs
                normalCount = 2;
                oddCount = 1;
                oneWayCount = 1;
                specsTier = SPECS_TIER.STABLE;
            } else if (L <= 10) {
                // Levels 6-10: 4 objects, moderate specs
                // Gradually increase odd shapes and one-way count
                const progress = L - 6; // 0-4
                normalCount = Math.max(1, 2 - Math.floor(progress / 2)); // 2,2,1,1,1
                oddCount = targetCount - normalCount; // Fill rest with odd
                oneWayCount = Math.min(2, 1 + Math.floor(progress / 2)); // 1,1,2,2,2
                specsTier = SPECS_TIER.MODERATE;
            } else {
                // Levels 11+: 5 objects, wild specs
                const progress = L - 11; // 0+
                normalCount = Math.max(0, 2 - Math.floor(progress / 3)); // 2,2,2,1,1,1,0...
                oddCount = targetCount - normalCount; // Fill rest with odd
                oneWayCount = Math.min(3, 2 + Math.floor(progress / 4)); // 2,2,2,2,3,3...
                specsTier = SPECS_TIER.WILD;
            }
            
            // Enforce target count exactly
            const currentTotal = normalCount + oddCount;
            if (currentTotal < targetCount) {
                // Add more odd shapes to reach target
                oddCount += (targetCount - currentTotal);
            } else if (currentTotal > targetCount) {
                // Remove odd shapes first, then normal if needed
                const excess = currentTotal - targetCount;
                if (oddCount >= excess) {
                    oddCount -= excess;
                } else {
                    normalCount -= (excess - oddCount);
                    oddCount = 0;
                }
            }
            
            // Clamp oneWayCount to not exceed total objects
            if (oneWayCount > targetCount) {
                console.warn(`Level ${L}: oneWayCount ${oneWayCount} exceeds targetCount ${targetCount}, clamping`);
                oneWayCount = targetCount;
            }
            
            return { normalCount, oddCount, oneWayCount, specsTier, targetCount };
        }
        
        // Select specs based on tier
        function selectSpecsForTier(tier, rand) {
            let combos;
            switch (tier) {
                case SPECS_TIER.STABLE:
                    combos = STABLE_COMBOS;
                    break;
                case SPECS_TIER.MODERATE:
                    combos = MODERATE_COMBOS;
                    break;
                case SPECS_TIER.WILD:
                default:
                    combos = WILD_COMBOS;
                    break;
            }
            const chosen = combos[Math.floor(rand() * combos.length)];
            return { gravity: chosen[0], rebound: chosen[1] };
        }

        // Select which face to make one-way on a shape
        function selectOneWayFace(shape, levelNum, rand) {
            const segments = shape.getSegments();
            if (segments.length === 0) return -1;
            
            // Calculate segment lengths
            const segLengths = segments.map((seg, idx) => {
                const dx = seg.b.x - seg.a.x;
                const dy = seg.b.y - seg.a.y;
                return { idx, length: Math.sqrt(dx*dx + dy*dy) };
            });
            
            // Sort by length descending
            segLengths.sort((a, b) => b.length - a.length);
            
            if (levelNum <= 7) {
                // Early levels: choose largest face (most readable)
                return segLengths[0].idx;
            } else if (levelNum <= 14) {
                // Mid levels: choose from top 50% of faces
                const topHalf = segLengths.slice(0, Math.max(1, Math.ceil(segLengths.length / 2)));
                return topHalf[Math.floor(rand() * topHalf.length)].idx;
            } else {
                // Late levels: any face
                return Math.floor(rand() * segments.length);
            }
        }

        const Utils = {
            dot(a, b) { return a.x * b.x + a.y * b.y; },
            length(v) { return Math.sqrt(v.x * v.x + v.y * v.y); },
            normalize(v) { const len = this.length(v); return len === 0 ? { x: 0, y: 0 } : { x: v.x / len, y: v.y / len }; },
            subtract(a, b) { return { x: a.x - b.x, y: a.y - b.y }; },
            add(a, b) { return { x: a.x + b.x, y: a.y + b.y }; },
            scale(v, s) { return { x: v.x * s, y: v.y * s }; },
            clamp(val, min, max) { return Math.max(min, Math.min(max, val)); },
            pointToSegment(p, a, b) {
                const ab = this.subtract(b, a), ap = this.subtract(p, a);
                const abLen2 = ab.x * ab.x + ab.y * ab.y;
                if (abLen2 === 0) return { dist: this.length(ap), closest: a, t: 0 };
                const t = this.clamp(this.dot(ap, ab) / abLen2, 0, 1);
                const closest = { x: a.x + t * ab.x, y: a.y + t * ab.y };
                return { dist: this.length(this.subtract(p, closest)), closest, t };
            },
            segmentNormal(a, b) { const dir = this.subtract(b, a); return this.normalize({ x: -dir.y, y: dir.x }); },
            
            // ========================================
            // CCD: Swept Circle vs Line Segment
            // Returns earliest time t in [0,1] when moving circle touches segment
            // ========================================
            sweptCircleSegment(p0, p1, radius, segA, segB) {
                // Motion vector
                const dx = p1.x - p0.x;
                const dy = p1.y - p0.y;
                const moveLen = Math.sqrt(dx * dx + dy * dy);
                if (moveLen < 0.0001) return null;
                
                // Check collision with segment interior (capsule approach)
                // Expand segment by radius and check ray intersection
                const segDir = this.subtract(segB, segA);
                const segLen = this.length(segDir);
                if (segLen < 0.0001) {
                    // Degenerate segment, treat as point/circle
                    return this.sweptCirclePoint(p0, p1, radius, segA);
                }
                
                const segNorm = { x: -segDir.y / segLen, y: segDir.x / segLen };
                
                // Find time when circle center is exactly radius away from infinite line
                // Line equation: dot(p - segA, segNorm) = 0
                // We want: dot(p0 + t*(p1-p0) - segA, segNorm) = ±radius
                const d0 = this.dot(this.subtract(p0, segA), segNorm);
                const d1 = this.dot(this.subtract(p1, segA), segNorm);
                const dDelta = d1 - d0;
                
                let tLine = null;
                let hitSide = 0;
                
                if (Math.abs(dDelta) > 0.0001) {
                    // Check both sides of the line
                    const t1 = (radius - d0) / dDelta;
                    const t2 = (-radius - d0) / dDelta;
                    
                    // Pick earliest valid time
                    if (t1 >= 0 && t1 <= 1) {
                        tLine = t1;
                        hitSide = 1;
                    }
                    if (t2 >= 0 && t2 <= 1 && (tLine === null || t2 < tLine)) {
                        tLine = t2;
                        hitSide = -1;
                    }
                }
                
                // If we have a line hit, verify it's within segment bounds
                let segmentHitT = null;
                if (tLine !== null) {
                    const hitX = p0.x + tLine * dx;
                    const hitY = p0.y + tLine * dy;
                    // Project hit point onto segment
                    const projT = this.dot(this.subtract({x: hitX, y: hitY}, segA), segDir) / (segLen * segLen);
                    if (projT >= 0 && projT <= 1) {
                        segmentHitT = tLine;
                    }
                }
                
                // Also check endpoint circles (corners)
                const tCornerA = this.sweptCirclePoint(p0, p1, radius, segA);
                const tCornerB = this.sweptCirclePoint(p0, p1, radius, segB);
                
                // Find earliest hit
                let bestT = null;
                let hitType = null;
                let hitPoint = null;
                let hitCorner = null;
                
                if (segmentHitT !== null && (bestT === null || segmentHitT < bestT)) {
                    bestT = segmentHitT;
                    hitType = 'segment';
                    const hitX = p0.x + bestT * dx;
                    const hitY = p0.y + bestT * dy;
                    // Closest point on segment
                    const projT = this.dot(this.subtract({x: hitX, y: hitY}, segA), segDir) / (segLen * segLen);
                    hitPoint = {
                        x: segA.x + projT * segDir.x,
                        y: segA.y + projT * segDir.y
                    };
                }
                
                if (tCornerA !== null && (bestT === null || tCornerA < bestT)) {
                    bestT = tCornerA;
                    hitType = 'cornerA';
                    hitPoint = segA;
                    hitCorner = segA;
                }
                
                if (tCornerB !== null && (bestT === null || tCornerB < bestT)) {
                    bestT = tCornerB;
                    hitType = 'cornerB';
                    hitPoint = segB;
                    hitCorner = segB;
                }
                
                if (bestT === null) return null;
                
                const contactX = p0.x + bestT * dx;
                const contactY = p0.y + bestT * dy;
                
                // Compute normal
                let normal;
                if (hitType === 'segment') {
                    // Normal from segment (consistent direction)
                    normal = { x: segNorm.x, y: segNorm.y };
                    // Ensure normal points toward ball
                    const d = this.dot(this.subtract({x: contactX, y: contactY}, hitPoint), normal);
                    if (d < 0) {
                        normal = { x: -normal.x, y: -normal.y };
                    }
                } else {
                    // Corner: normal from corner to ball center
                    normal = this.normalize(this.subtract({x: contactX, y: contactY}, hitCorner));
                }
                
                return {
                    t: bestT,
                    contactX,
                    contactY,
                    hitPoint,
                    normal,
                    hitType,
                    hitCorner
                };
            },
            
            // CCD: Swept Circle vs Point (for corners)
            sweptCirclePoint(p0, p1, radius, point) {
                // Solve: |p0 + t*(p1-p0) - point| = radius
                const dx = p1.x - p0.x;
                const dy = p1.y - p0.y;
                const fx = p0.x - point.x;
                const fy = p0.y - point.y;
                
                const a = dx * dx + dy * dy;
                const b = 2 * (fx * dx + fy * dy);
                const c = fx * fx + fy * fy - radius * radius;
                
                const discriminant = b * b - 4 * a * c;
                if (discriminant < 0) return null;
                
                const sqrtD = Math.sqrt(discriminant);
                const t1 = (-b - sqrtD) / (2 * a);
                const t2 = (-b + sqrtD) / (2 * a);
                
                // Return earliest time in [0, 1]
                if (t1 >= 0 && t1 <= 1) return t1;
                if (t2 >= 0 && t2 <= 1) return t2;
                return null;
            },
            
            // CCD: Swept Circle vs Arc (for half-circle, etc.)
            sweptCircleArc(p0, p1, radius, arcCenter, arcRadius, arcStartAngle, arcEndAngle) {
                // Solve: |p0 + t*(p1-p0) - arcCenter| = arcRadius + radius (outer hit)
                // or = arcRadius - radius (inner hit, if ball inside arc)
                const dx = p1.x - p0.x;
                const dy = p1.y - p0.y;
                const fx = p0.x - arcCenter.x;
                const fy = p0.y - arcCenter.y;
                
                const a = dx * dx + dy * dy;
                const b = 2 * (fx * dx + fy * dy);
                
                // Check outer collision (ball outside arc)
                const targetRadius = arcRadius + radius;
                const c = fx * fx + fy * fy - targetRadius * targetRadius;
                
                const discriminant = b * b - 4 * a * c;
                if (discriminant < 0) return null;
                
                const sqrtD = Math.sqrt(discriminant);
                const t1 = (-b - sqrtD) / (2 * a);
                const t2 = (-b + sqrtD) / (2 * a);
                
                // Check each solution
                const candidates = [];
                for (const t of [t1, t2]) {
                    if (t >= 0 && t <= 1) {
                        const hitX = p0.x + t * dx;
                        const hitY = p0.y + t * dy;
                        // Check if hit point angle is within arc span
                        const angle = Math.atan2(hitY - arcCenter.y, hitX - arcCenter.x);
                        if (this.isAngleInArc(angle, arcStartAngle, arcEndAngle)) {
                            candidates.push(t);
                        }
                    }
                }
                
                if (candidates.length === 0) return null;
                const bestT = Math.min(...candidates);
                
                const contactX = p0.x + bestT * dx;
                const contactY = p0.y + bestT * dy;
                const normal = this.normalize(this.subtract({x: contactX, y: contactY}, arcCenter));
                
                // Hit point is on arc surface
                const hitPoint = {
                    x: arcCenter.x + normal.x * arcRadius,
                    y: arcCenter.y + normal.y * arcRadius
                };
                
                return {
                    t: bestT,
                    contactX,
                    contactY,
                    hitPoint,
                    normal,
                    hitType: 'arc'
                };
            },
            
            isAngleInArc(angle, startAngle, endAngle) {
                // Normalize angles to [0, 2π]
                const norm = (a) => ((a % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);
                const a = norm(angle);
                const s = norm(startAngle);
                const e = norm(endAngle);
                
                if (s <= e) {
                    return a >= s && a <= e;
                } else {
                    // Arc wraps around 0
                    return a >= s || a <= e;
                }
            },
            
            // Shared collision resolution - used by BOTH runtime and preview
            // Returns { collided, normal, closest, penetration } or null if no collision
            resolveSegmentCollision(ballPos, ballRadius, seg) {
                const result = this.pointToSegment(ballPos, seg.a, seg.b);
                if (result.dist >= ballRadius) return null;
                
                const penetration = ballRadius - result.dist;
                let normal;
                
                // ========================================
                // ARC COLLISION: Use radial normal from circle center
                // This is critical for correct bounce direction on curved surfaces
                // ========================================
                if (seg.isArc && seg.arcCenter) {
                    // For arc segments, normal is ALWAYS radial (from circle center to ball)
                    normal = this.subtract(ballPos, seg.arcCenter);
                    const normalLen = this.length(normal);
                    if (normalLen < 0.001) {
                        // Ball exactly at center (shouldn't happen), use segment normal as fallback
                        normal = this.segmentNormal(seg.a, seg.b);
                    } else {
                        normal = this.scale(normal, 1 / normalLen);
                    }
                    
                    return {
                        collided: true,
                        normal: normal,
                        closest: result.closest,
                        penetration: penetration,
                        t: result.t,
                        isArc: true
                    };
                }
                
                // ========================================
                // FLAT SEGMENT COLLISION (existing logic)
                // ========================================
                
                // Corner threshold: if t is near 0 or 1, treat as corner collision
                // Increased threshold for more robust corner detection at various angles
                const CORNER_THRESHOLD = 0.05; // ~5% of segment length (was 2%)
                const isCornerA = result.t <= CORNER_THRESHOLD;
                const isCornerB = result.t >= (1 - CORNER_THRESHOLD);
                
                if (isCornerA || isCornerB) {
                    // Corner collision: normal points from vertex to ball center
                    const vertex = isCornerA ? seg.a : seg.b;
                    normal = this.subtract(ballPos, vertex);
                    const normalLen = this.length(normal);
                    if (normalLen < 0.001) {
                        // Ball exactly on vertex, use segment normal as fallback
                        normal = this.segmentNormal(seg.a, seg.b);
                    } else {
                        normal = this.scale(normal, 1 / normalLen);
                    }
                } else {
                    // Mid-segment collision: normal from closest point to ball
                    normal = this.subtract(ballPos, result.closest);
                    const normalLen = this.length(normal);
                    if (normalLen < 0.001) {
                        normal = this.segmentNormal(seg.a, seg.b);
                    } else {
                        normal = this.scale(normal, 1 / normalLen);
                    }
                }
                
                return {
                    collided: true,
                    normal: normal,
                    closest: result.closest,
                    penetration: penetration,
                    t: result.t
                };
            },
            
            // Reflect velocity with restitution and friction
            reflectVelocity(vel, normal, restitution, friction) {
                const velDotNormal = this.dot(vel, normal);
                if (velDotNormal >= 0) return null; // Moving away, no reflection needed
                
                const velNormal = this.scale(normal, velDotNormal);
                const velTangent = this.subtract(vel, velNormal);
                const newVel = this.add(
                    this.scale(velNormal, -restitution),
                    this.scale(velTangent, friction)
                );
                return { vel: newVel, impactSpeed: Math.abs(velDotNormal) };
            },
            
            // ========================================
            // SHARED ONE-WAY COLLISION EVALUATOR
            // Single source of truth for both preview and sim
            // ========================================
            evaluateOneWayCollision(shape, seg, segIdx) {
                // Default: not one-way, bounce normally
                const result = {
                    isOneWay: false,
                    isBounceSide: true,
                    shouldVanish: false
                };
                
                // Hard-block: Lines cannot be one-way (single segment has no meaningful "side")
                if (shape.oneWayEligible === false || shape.shapeType === ShapeTypeEnum.LINE) {
                    return result;
                }
                
                // Check if shape has one-way enabled
                if (!shape.oneWayEnabled) {
                    return result;
                }
                
                result.isOneWay = true;
                
                // Determine the logical side index for this segment
                // For shapes with grouped segments (like SAWTOOTH_RAMP), use seg.sideIndex
                // For regular shapes, use segIdx directly
                const logicalSideIndex = (seg.sideIndex !== undefined) ? seg.sideIndex : segIdx;
                
                // Determine if this is an allowed bounce side
                // Method 1: HalfCircle style - segment has explicit isActiveSide
                if (seg.isActiveSide !== undefined) {
                    result.isBounceSide = seg.isActiveSide;
                    result.shouldVanish = !seg.isActiveSide;
                }
                // Method 2: Multiple allowed sides array (new)
                else if (shape.oneWayAllowedSides && shape.oneWayAllowedSides.length > 0) {
                    // Use logicalSideIndex instead of segIdx for grouped segments
                    const isAllowedSide = shape.oneWayAllowedSides.includes(logicalSideIndex);
                    result.isBounceSide = isAllowedSide;
                    result.shouldVanish = !isAllowedSide;
                }
                // Method 3: Legacy single face index
                else if (shape.oneWayFaceIndex >= 0) {
                    // Use logicalSideIndex instead of segIdx for grouped segments
                    const isAllowedSide = (logicalSideIndex === shape.oneWayFaceIndex);
                    result.isBounceSide = isAllowedSide;
                    result.shouldVanish = !isAllowedSide;
                }
                // Method 4: No valid one-way config - default to bounce
                else {
                    result.isOneWay = false;
                    result.shouldVanish = false;
                }
                
                if (DEBUG_ONEWAY) {
                    console.log('[ONEWAY] evaluateOneWayCollision:', 
                        'shape:', shape.shapeType, 
                        'segIdx:', segIdx,
                        'sideIndex:', logicalSideIndex,
                        'oneWayEnabled:', shape.oneWayEnabled,
                        'allowedSides:', shape.oneWayAllowedSides,
                        'isActiveSide:', seg.isActiveSide,
                        'result:', result);
                }
                
                return result;
            },
            
            roundRect(ctx, x, y, w, h, r) {
                ctx.beginPath();
                ctx.moveTo(x + r, y);
                ctx.lineTo(x + w - r, y);
                ctx.quadraticCurveTo(x + w, y, x + w, y + r);
                ctx.lineTo(x + w, y + h - r);
                ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
                ctx.lineTo(x + r, y + h);
                ctx.quadraticCurveTo(x, y + h, x, y + h - r);
                ctx.lineTo(x, y + r);
                ctx.quadraticCurveTo(x, y, x + r, y);
                ctx.closePath();
            },
            randomRange(min, max) {
                return min + Math.random() * (max - min);
            }
        };

        // ========================================
        // VFX MANAGER - Particles, Confetti, Shake
        // ========================================
        class VFXManager {
            constructor() {
                this.particles = [];
                this.confetti = [];
                this.screenShake = { x: 0, y: 0, time: 0 };
                this.swoosh = { active: false, time: 0 };
            }
            
            reset() {
                this.particles = [];
                this.confetti = [];
                this.screenShake = { x: 0, y: 0, time: 0 };
                this.swoosh = { active: false, time: 0 };
            }
            
            // Spawn collision particles at contact point
            spawnCollisionParticles(x, y, normalX, normalY, speed) {
                const count = Math.floor(Utils.randomRange(ANIM.particleCountMin, ANIM.particleCountMax));
                const baseAngle = Math.atan2(normalY, normalX);
                
                for (let i = 0; i < count; i++) {
                    // Spread particles in a cone around the normal
                    const angle = baseAngle + Utils.randomRange(-Math.PI * 0.6, Math.PI * 0.6);
                    const spd = Utils.randomRange(ANIM.particleSpeedMin, ANIM.particleSpeedMax) * (0.5 + speed / 600);
                    const life = Utils.randomRange(ANIM.particleLifetimeMin, ANIM.particleLifetimeMax);
                    const size = Utils.randomRange(ANIM.particleSizeMin, ANIM.particleSizeMax);
                    const color = THEME.particleColors[Math.floor(Math.random() * THEME.particleColors.length)];
                    
                    this.particles.push({
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * spd,
                        vy: Math.sin(angle) * spd,
                        life: life,
                        maxLife: life,
                        size: size,
                        color: color,
                        gravity: 300
                    });
                }
            }
            
            // Spawn confetti burst for success
            spawnConfetti(x, y) {
                for (let i = 0; i < ANIM.confettiCount; i++) {
                    const angle = Utils.randomRange(0, Math.PI * 2);
                    const spd = Utils.randomRange(100, 300);
                    const color = THEME.confettiColors[Math.floor(Math.random() * THEME.confettiColors.length)];
                    const isRect = Math.random() > 0.5;
                    
                    this.confetti.push({
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * spd,
                        vy: Math.sin(angle) * spd - 150, // Initial upward boost
                        life: ANIM.confettiLifetime,
                        maxLife: ANIM.confettiLifetime,
                        size: Utils.randomRange(4, 8),
                        color: color,
                        rotation: Math.random() * Math.PI * 2,
                        rotationSpeed: Utils.randomRange(-10, 10),
                        isRect: isRect,
                        gravity: 400
                    });
                }
            }
            
            // Trigger screen shake
            triggerShake(intensity) {
                const clampedIntensity = Math.min(intensity, ANIM.shakeIntensity);
                this.screenShake.time = ANIM.shakeDuration;
                this.screenShake.intensity = clampedIntensity;
            }
            
            // Trigger swoosh effect
            triggerSwoosh() {
                this.swoosh.active = true;
                this.swoosh.time = ANIM.swooshDuration;
            }
            
            update(dt) {
                // Update particles
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];
                    p.vy += p.gravity * dt;
                    p.x += p.vx * dt;
                    p.y += p.vy * dt;
                    p.life -= dt;
                    
                    if (p.life <= 0) {
                        this.particles.splice(i, 1);
                    }
                }
                
                // Update confetti
                for (let i = this.confetti.length - 1; i >= 0; i--) {
                    const c = this.confetti[i];
                    c.vy += c.gravity * dt;
                    c.vx *= 0.99; // Air resistance
                    c.x += c.vx * dt;
                    c.y += c.vy * dt;
                    c.rotation += c.rotationSpeed * dt;
                    c.life -= dt;
                    
                    if (c.life <= 0) {
                        this.confetti.splice(i, 1);
                    }
                }
                
                // Update screen shake
                if (this.screenShake.time > 0) {
                    this.screenShake.time -= dt;
                    const t = this.screenShake.time / ANIM.shakeDuration;
                    const intensity = this.screenShake.intensity * t;
                    this.screenShake.x = (Math.random() - 0.5) * 2 * intensity;
                    this.screenShake.y = (Math.random() - 0.5) * 2 * intensity;
                } else {
                    this.screenShake.x = 0;
                    this.screenShake.y = 0;
                }
                
                // Update swoosh
                if (this.swoosh.active) {
                    this.swoosh.time -= dt;
                    if (this.swoosh.time <= 0) {
                        this.swoosh.active = false;
                    }
                }
            }
            
            draw(ctx) {
                // Draw particles
                for (const p of this.particles) {
                    const alpha = p.life / p.maxLife;
                    const size = p.size * (0.5 + alpha * 0.5);
                    
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, size, 0, Math.PI * 2);
                    ctx.fillStyle = p.color;
                    ctx.globalAlpha = alpha;
                    ctx.fill();
                }
                
                // Draw confetti
                for (const c of this.confetti) {
                    const alpha = Math.min(1, c.life / (c.maxLife * 0.3));
                    
                    ctx.save();
                    ctx.translate(c.x, c.y);
                    ctx.rotate(c.rotation);
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = c.color;
                    
                    if (c.isRect) {
                        ctx.fillRect(-c.size / 2, -c.size / 4, c.size, c.size / 2);
                    } else {
                        ctx.beginPath();
                        ctx.arc(0, 0, c.size / 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    ctx.restore();
                }
                
                ctx.globalAlpha = 1;
            }
            
            getSwooshAlpha() {
                if (!this.swoosh.active) return 0;
                const t = this.swoosh.time / ANIM.swooshDuration;
                // Fade in then out
                return t > 0.5 ? (1 - t) * 2 : t * 2;
            }
        }

        // Size reduction factor (35% smaller = 65% of original)
        const SIZE_SCALE = 0.65;

        class Ball {
            constructor(x, y, radius = 15 * SIZE_SCALE) {
                this.x = x; 
                this.y = y; 
                this.radius = radius;
                this.vx = 0; 
                this.vy = 0; 
                this.restTimer = 0;
                this.visible = true;
                
                // Vanish animation state
                this.vanishing = false;
                this.vanishProgress = 0;
                this.vanishX = 0;
                this.vanishY = 0;
                
                // Trail system - circular buffer
                this.trail = [];
                this.trailIndex = 0;
                this.lastTrailX = x;
                this.lastTrailY = y;
                
                // Squash/stretch
                this.squashX = 1;
                this.squashY = 1;
                this.squashAngle = 0;
            }
            
            reset(x, y) { 
                this.x = x; 
                this.y = y; 
                this.vx = 0; 
                this.vy = 0; 
                this.restTimer = 0; 
                this.visible = true;
                // Reset vanish state
                this.vanishing = false;
                this.vanishProgress = 0;
                // Clear trail
                this.trail = [];
                this.trailIndex = 0;
                this.lastTrailX = x;
                this.lastTrailY = y;
                // Reset squash
                this.squashX = 1;
                this.squashY = 1;
                this.squashAngle = 0;
            }
            
            // Start vanish animation at collision point
            startVanish(x, y) {
                // Prevent multiple calls (idempotent)
                if (this.vanishing) return;
                
                if (DEBUG_ONEWAY) console.log('[ONEWAY] Ball vanish started at', x.toFixed(1), y.toFixed(1));
                this.vanishing = true;
                this.vanishProgress = 0;
                this.vanishX = x;
                this.vanishY = y;
                this.vx = 0;
                this.vy = 0;
            }
            
            // Returns true when vanish animation is complete
            isVanishComplete() {
                const complete = this.vanishing && this.vanishProgress >= 1;
                if (complete && DEBUG_ONEWAY) {
                    console.log('[ONEWAY] Vanish animation complete, progress=', this.vanishProgress.toFixed(2));
                }
                return complete;
            }
            
            // Called on collision to trigger squash effect
            onCollision(normalX, normalY, impactSpeed) {
                // Calculate squash amount based on impact speed
                const intensity = Math.min(1, impactSpeed / 600);
                const squash = 1 - ANIM.squashAmount * intensity;
                const stretch = 1 + ANIM.squashAmount * 0.5 * intensity;
                
                // Squash along normal, stretch perpendicular
                this.squashX = squash;
                this.squashY = stretch;
                this.squashAngle = Math.atan2(normalY, normalX);
            }
            
            update(dt, gravity) {
                // Handle vanish animation
                if (this.vanishing) {
                    this.vanishProgress += dt * 1.2; // ~800-1000ms animation (was dt*5 = 200ms)
                    this.x = this.vanishX;
                    this.y = this.vanishY;
                    return;
                }
                
                this.vy += gravity * dt; 
                this.x += this.vx * dt; 
                this.y += this.vy * dt;
                const speed = Utils.length({ x: this.vx, y: this.vy });
                this.restTimer = speed < 5 ? this.restTimer + dt : 0;
                
                // Update trail - only add point if moved enough distance
                const dx = this.x - this.lastTrailX;
                const dy = this.y - this.lastTrailY;
                const distMoved = Math.sqrt(dx * dx + dy * dy);
                
                if (distMoved >= ANIM.trailMinDistance && speed > ANIM.trailSpeedThreshold) {
                    // Add new trail point
                    const point = {
                        x: this.x,
                        y: this.y,
                        life: 1.0,
                        speed: speed,
                        size: this.radius * 0.8
                    };
                    
                    if (this.trail.length < ANIM.trailMaxPoints) {
                        this.trail.push(point);
                    } else {
                        // Circular buffer - overwrite oldest
                        this.trail[this.trailIndex] = point;
                        this.trailIndex = (this.trailIndex + 1) % ANIM.trailMaxPoints;
                    }
                    
                    this.lastTrailX = this.x;
                    this.lastTrailY = this.y;
                }
                
                // Fade out trail points
                for (let i = 0; i < this.trail.length; i++) {
                    this.trail[i].life -= dt * ANIM.trailFadeSpeed;
                    this.trail[i].size *= 0.97; // Shrink over time
                }
                
                // Remove dead trail points (life <= 0)
                this.trail = this.trail.filter(p => p.life > 0);
                
                // Decay squash/stretch back to normal
                this.squashX += (1 - this.squashX) * ANIM.squashDecay * dt;
                this.squashY += (1 - this.squashY) * ANIM.squashDecay * dt;
            }
            
            drawTrail(ctx) {
                if (this.trail.length < 2) return;
                
                const speed = Utils.length({ x: this.vx, y: this.vy });
                const isHighSpeed = speed > ANIM.trailHighSpeedThreshold;
                
                // Sort trail by life (oldest first for proper layering)
                const sortedTrail = [...this.trail].sort((a, b) => a.life - b.life);
                
                for (let i = 0; i < sortedTrail.length; i++) {
                    const point = sortedTrail[i];
                    const alpha = point.life * 0.6; // Max alpha 0.6
                    
                    if (alpha <= 0.01) continue;
                    
                    // Size decreases with age
                    const size = Math.max(2, point.size * point.life);
                    
                    // Color based on speed
                    let color;
                    if (isHighSpeed || point.speed > ANIM.trailHighSpeedThreshold) {
                        color = THEME.trailColorFast;
                    } else {
                        color = THEME.trailColor;
                    }
                    
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, size, 0, Math.PI * 2);
                    ctx.fillStyle = color;
                    ctx.globalAlpha = alpha;
                    ctx.fill();
                    
                    // Add glow for high speed
                    if (isHighSpeed && point.life > 0.5) {
                        ctx.beginPath();
                        ctx.arc(point.x, point.y, size * 1.5, 0, Math.PI * 2);
                        ctx.fillStyle = THEME.trailGlow;
                        ctx.globalAlpha = alpha * 0.3;
                        ctx.fill();
                    }
                }
                
                ctx.globalAlpha = 1;
            }
            
            draw(ctx) {
                if (!this.visible) return;
                
                // Draw trail BEFORE ball
                this.drawTrail(ctx);
                
                // Save context for squash/stretch transform
                ctx.save();
                
                // Handle vanish animation
                if (this.vanishing) {
                    const progress = Math.min(1, this.vanishProgress);
                    const scale = 1 - progress;
                    const alpha = 1 - progress;
                    
                    ctx.globalAlpha = alpha;
                    ctx.translate(this.vanishX, this.vanishY);
                    ctx.scale(scale, scale);
                    ctx.translate(-this.vanishX, -this.vanishY);
                    
                    // Draw shrinking ball at vanish point
                    const gradient = ctx.createRadialGradient(
                        this.vanishX - this.radius * 0.3, this.vanishY - this.radius * 0.3, 0,
                        this.vanishX, this.vanishY, this.radius
                    );
                    gradient.addColorStop(0, '#FFFFFF');
                    gradient.addColorStop(0.3, THEME.ballFillStart);
                    gradient.addColorStop(0.8, THEME.ballFillEnd);
                    gradient.addColorStop(1, THEME.ballStroke);
                    
                    ctx.beginPath();
                    ctx.arc(this.vanishX, this.vanishY, this.radius, 0, Math.PI * 2);
                    ctx.fillStyle = gradient;
                    ctx.fill();
                    
                    // Poof particles effect
                    if (progress < 0.5) {
                        const puffAlpha = (0.5 - progress) * 2;
                        const puffRadius = this.radius * (1 + progress * 3);
                        ctx.beginPath();
                        ctx.arc(this.vanishX, this.vanishY, puffRadius, 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(255, 200, 150, ${puffAlpha * 0.4})`;
                        ctx.fill();
                    }
                    
                    ctx.restore();
                    return;
                }
                
                // Apply squash/stretch transformation
                ctx.translate(this.x, this.y);
                ctx.rotate(this.squashAngle);
                ctx.scale(this.squashX, this.squashY);
                ctx.translate(-this.x, -this.y);
                
                // Shadow
                ctx.beginPath();
                ctx.arc(this.x + 2, this.y + 3, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(0, 0, 0, 0.12)';
                ctx.fill();
                
                // Ball gradient using skin colors
                const gradient = ctx.createRadialGradient(
                    this.x - this.radius * 0.3, this.y - this.radius * 0.3, 0,
                    this.x, this.y, this.radius
                );
                gradient.addColorStop(0, '#FFFFFF');
                gradient.addColorStop(0.3, THEME.ballFillStart);
                gradient.addColorStop(0.8, THEME.ballFillEnd);
                gradient.addColorStop(1, THEME.ballStroke);
                
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();
                
                // Colored rim
                ctx.strokeStyle = THEME.ballStroke;
                ctx.lineWidth = 1.5;
                ctx.stroke();
                
                // Highlight
                ctx.beginPath();
                ctx.arc(this.x - this.radius * 0.3, this.y - this.radius * 0.3, this.radius * 0.3, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.fill();
                
                ctx.restore();
            }
        }

        class Shape {
            constructor(x, y, colorIndex = 0) {
                this.x = x; this.y = y; this.startX = x; this.startY = y;
                this.savedX = x; this.savedY = y; this.savedRotation = 0;
                this.rotation = 0;
                this.isDragging = false; this.isRotating = false;
                this.hasBeenHit = false;
                this.hasBeenMoved = false;
                this.dragStartX = x; this.dragStartY = y;
                this.rotateHandleDistance = 35 * SIZE_SCALE; 
                this.rotateHandleRadius = 8 * SIZE_SCALE;
                this.colorIndex = colorIndex;
                this.opacity = 1;
                this.isDisappearing = false;
                this.isSelected = false;
                this.removedByPowerup = false;  // Flag for R powerup removal
                
                // One-way surface support (for non-HalfCircle shapes)
                this.oneWayEnabled = false;
                this.oneWayFaceIndex = -1;  // Legacy: single allowed side index
                this.oneWayAllowedSides = [];  // NEW: array of allowed side indices
                
                // Hit feedback
                this.hitScale = 1;
                this.hitHighlight = 0;
            }
            
            getColors() {
                // Unselected: neutral slate/graphite
                // Selected: bright accent with glow
                if (this.isSelected) {
                    return {
                        fill: THEME.shapeSelectedFill,
                        stroke: THEME.shapeSelected,
                        glow: THEME.shapeSelectedGlow
                    };
                }
                return {
                    fill: THEME.shapeFill,
                    stroke: THEME.shapeStroke,
                    glow: THEME.shapeGlow
                };
            }
            getCenter() { return { x: this.x, y: this.y }; }
            getRotateHandlePos() {
                const center = this.getCenter();
                return { x: center.x + Math.cos(this.rotation - Math.PI/2) * this.rotateHandleDistance,
                         y: center.y + Math.sin(this.rotation - Math.PI/2) * this.rotateHandleDistance };
            }
            containsRotateHandle(px, py) {
                const handle = this.getRotateHandlePos();
                return Math.sqrt((px - handle.x)**2 + (py - handle.y)**2) < this.rotateHandleRadius + 8;
            }
            rotatePoint(point, center, angle) {
                const cos = Math.cos(angle), sin = Math.sin(angle);
                const dx = point.x - center.x, dy = point.y - center.y;
                return { x: center.x + dx * cos - dy * sin, y: center.y + dx * sin + dy * cos };
            }
            move(dx, dy, canvasWidth, canvasHeight, bottomLimit) {
                this.x += dx; this.y += dy;
                this.clampToCanvas(canvasWidth, canvasHeight, bottomLimit);
            }
            clampToCanvas(w, h, bottomLimit) {}
            
            // Called when shape is hit for the first time
            onHit() {
                this.hitScale = ANIM.shapeHitScale;
                this.hitHighlight = 1;
            }
            
            drawRotateHandle(ctx) {
                const center = this.getCenter(), handle = this.getRotateHandlePos();
                ctx.beginPath(); ctx.moveTo(center.x, center.y); ctx.lineTo(handle.x, handle.y);
                ctx.strokeStyle = this.isSelected ? THEME.shapeSelectedGlow : 'rgba(148, 163, 184, 0.3)';
                ctx.lineWidth = 1.5;
                ctx.setLineDash([4, 4]); ctx.stroke(); ctx.setLineDash([]);
                ctx.beginPath(); ctx.arc(handle.x, handle.y, this.rotateHandleRadius, 0, Math.PI * 2);
                ctx.fillStyle = this.isSelected ? 'rgba(124, 92, 255, 0.2)' : 'rgba(71, 85, 105, 0.3)';
                ctx.fill();
                ctx.strokeStyle = this.isSelected ? THEME.shapeSelectedAccent : THEME.textMuted;
                ctx.lineWidth = 2; ctx.stroke();
            }
            drawHitCheck(ctx, x, y) {
                if (this.hasBeenHit) {
                    ctx.beginPath();
                    ctx.arc(x, y, 7 * SIZE_SCALE, 0, Math.PI * 2);
                    const grad = ctx.createRadialGradient(x, y, 0, x, y, 7 * SIZE_SCALE);
                    grad.addColorStop(0, THEME.successLight);
                    grad.addColorStop(1, THEME.success);
                    ctx.fillStyle = grad;
                    ctx.fill();
                    ctx.fillStyle = '#fff';
                    ctx.font = `bold ${8 * SIZE_SCALE}px sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('✓', x, y);
                }
            }
            is2D() { return true; }
            
            // Helper to draw one-way highlight on polygon shapes
            // Draws the allowed bounce sides in highlight color
            drawOneWayHighlight(ctx) {
                if (!this.oneWayEnabled) return;
                
                const segments = this.getSegments();
                
                // Determine which sides to highlight
                let allowedSides = [];
                if (this.oneWayAllowedSides && this.oneWayAllowedSides.length > 0) {
                    allowedSides = this.oneWayAllowedSides;
                } else if (this.oneWayFaceIndex >= 0) {
                    allowedSides = [this.oneWayFaceIndex];
                }
                
                if (allowedSides.length === 0) return;
                
                ctx.strokeStyle = THEME.oneWayHighlight;
                ctx.lineWidth = this.isSelected ? 4.5 : 3;
                // NO shadow/glow - keep clean look
                ctx.shadowBlur = 0;
                ctx.shadowColor = 'transparent';
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                // Highlight segments based on their logical side index
                // For shapes with grouped segments (like SAWTOOTH_RAMP), use seg.sideIndex
                // For regular shapes, use segment array index
                for (let i = 0; i < segments.length; i++) {
                    const seg = segments[i];
                    const logicalSideIndex = (seg.sideIndex !== undefined) ? seg.sideIndex : i;
                    
                    if (allowedSides.includes(logicalSideIndex)) {
                        ctx.beginPath();
                        ctx.moveTo(seg.a.x, seg.a.y);
                        ctx.lineTo(seg.b.x, seg.b.y);
                        ctx.stroke();
                    }
                }
            }
            
            startDisappear() { 
                this.isDisappearing = true;
                this.onHit(); // Trigger hit feedback
            }
            update(dt) {
                // Fade opacity when disappearing
                if (this.isDisappearing && this.opacity > 0) {
                    this.opacity -= dt * 3; // Slightly slower fade for juicier feel
                    if (this.opacity < 0) this.opacity = 0;
                }
                
                // Decay hit scale back to 1
                if (this.hitScale > 1) {
                    this.hitScale += (1 - this.hitScale) * ANIM.shapeHitScaleDecay * dt;
                    if (this.hitScale < 1.01) this.hitScale = 1;
                }
                
                // Decay hit highlight
                if (this.hitHighlight > 0) {
                    this.hitHighlight -= dt / ANIM.shapeHighlightDuration;
                    if (this.hitHighlight < 0) this.hitHighlight = 0;
                }
            }
            isVisible() { return this.opacity > 0.01; }
            savePosition() {
                this.savedX = this.x; this.savedY = this.y; this.savedRotation = this.rotation;
            }
            restorePosition() {
                this.x = this.savedX; this.y = this.savedY; this.rotation = this.savedRotation;
                // Only restore visibility if NOT removed by powerup
                if (!this.removedByPowerup) {
                    this.opacity = 1; this.isDisappearing = false; this.hasBeenHit = false;
                }
                this.hitScale = 1; this.hitHighlight = 0;
            }
        }

        class Triangle extends Shape {
            constructor(x, y, leg1, leg2, slopeDirection = 'left', colorIndex = 0) {
                super(x, y, colorIndex);
                this.leg1 = leg1 * SIZE_SCALE; 
                this.leg2 = leg2 * SIZE_SCALE; 
                this.slopeDirection = slopeDirection;
                this.shapeType = slopeDirection === 'left' ? ShapeTypeEnum.TRIANGLE_LEFT : ShapeTypeEnum.TRIANGLE_RIGHT;
            }
            getLocalVertices() {
                const h1 = this.leg1 / 2, h2 = this.leg2 / 2;
                return this.slopeDirection === 'left' ?
                    [{ x: -h1, y: h2 }, { x: h1, y: h2 }, { x: -h1, y: -h2 }] :
                    [{ x: -h1, y: h2 }, { x: h1, y: h2 }, { x: h1, y: -h2 }];
            }
            getVertices() {
                const local = this.getLocalVertices(), center = { x: this.x, y: this.y };
                return local.map(v => this.rotatePoint({ x: center.x + v.x, y: center.y + v.y }, center, this.rotation));
            }
            getSegments() { const v = this.getVertices(); return [{ a: v[0], b: v[1] }, { a: v[1], b: v[2] }, { a: v[2], b: v[0] }]; }
            containsPoint(px, py) {
                const v = this.getVertices();
                const sign = (p1x, p1y, p2, p3) => (p1x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1y - p3.y);
                const d1 = sign(px, py, v[0], v[1]), d2 = sign(px, py, v[1], v[2]), d3 = sign(px, py, v[2], v[0]);
                return !((d1 < 0 || d2 < 0 || d3 < 0) && (d1 > 0 || d2 > 0 || d3 > 0));
            }
            clampToCanvas(w, h, bottomLimit) {
                const margin = 10, halfSize = Math.max(this.leg1, this.leg2) / 2 + 10;
                this.x = Utils.clamp(this.x, halfSize + margin, w - halfSize - margin);
                this.y = Utils.clamp(this.y, halfSize + margin, bottomLimit - halfSize - margin);
            }
            draw(ctx, isActive = false) {
                if (!this.isVisible()) return;
                ctx.save();
                ctx.globalAlpha = this.opacity;
                
                const colors = this.getColors();
                
                // Apply hit scale
                if (this.hitScale !== 1) {
                    ctx.translate(this.x, this.y);
                    ctx.scale(this.hitScale, this.hitScale);
                    ctx.translate(-this.x, -this.y);
                }
                
                const v = this.getVertices();
                
                // Shadow
                ctx.beginPath(); 
                ctx.moveTo(v[0].x + 2, v[0].y + 3); 
                ctx.lineTo(v[1].x + 2, v[1].y + 3); 
                ctx.lineTo(v[2].x + 2, v[2].y + 3); 
                ctx.closePath();
                ctx.fillStyle = 'rgba(0, 0, 0, 0.25)';
                ctx.fill();
                
                // Selection glow backdrop (drawn BEFORE main shape)
                if (this.isSelected) {
                    ctx.shadowColor = THEME.shapeSelectedGlow;
                    ctx.shadowBlur = 20;
                }
                
                // Main shape fill
                ctx.beginPath(); ctx.moveTo(v[0].x, v[0].y); ctx.lineTo(v[1].x, v[1].y); ctx.lineTo(v[2].x, v[2].y); ctx.closePath();
                ctx.fillStyle = colors.fill;
                ctx.fill();
                
                // Hit highlight glow (temporary on collision)
                if (this.hitHighlight > 0) {
                    ctx.shadowColor = THEME.shapeHitHighlight;
                    ctx.shadowBlur = 25 * this.hitHighlight;
                }
                
                // Stroke - thicker and brighter when selected
                ctx.strokeStyle = colors.stroke; 
                ctx.lineWidth = this.isSelected ? 3.5 : 2;
                ctx.lineJoin = 'round';
                ctx.stroke();
                ctx.shadowBlur = 0;
                
                // One-way highlight
                this.drawOneWayHighlight(ctx);
                
                this.drawRotateHandle(ctx);
                this.drawHitCheck(ctx, this.x, this.y);
                ctx.restore();
            }
        }

        class LineSegment extends Shape {
            constructor(x, y, length, angle, colorIndex = 0) {
                super(x, y, colorIndex);
                this.length = length * SIZE_SCALE; 
                this.baseAngle = angle;
                this.shapeType = ShapeTypeEnum.LINE;
                this.oneWayEligible = false;  // Lines cannot be one-way (single segment has no meaningful "side")
            }
            getEndpoints() {
                const totalAngle = this.baseAngle + this.rotation, halfLen = this.length / 2;
                const dx = Math.cos(totalAngle) * halfLen, dy = Math.sin(totalAngle) * halfLen;
                return { a: { x: this.x - dx, y: this.y - dy }, b: { x: this.x + dx, y: this.y + dy } };
            }
            getSegments() { const e = this.getEndpoints(); return [{ a: e.a, b: e.b }]; }
            containsPoint(px, py) { return Utils.pointToSegment({ x: px, y: py }, this.getEndpoints().a, this.getEndpoints().b).dist < 15; }
            clampToCanvas(w, h, bottomLimit) {
                const margin = 10, halfLen = this.length / 2 + 10;
                this.x = Utils.clamp(this.x, halfLen + margin, w - halfLen - margin);
                this.y = Utils.clamp(this.y, halfLen + margin, bottomLimit - halfLen - margin);
            }
            is2D() { return false; }
            draw(ctx, isActive = false) {
                if (!this.isVisible()) return;
                ctx.save();
                ctx.globalAlpha = this.opacity;
                
                const colors = this.getColors();
                
                // Apply hit scale
                if (this.hitScale !== 1) {
                    ctx.translate(this.x, this.y);
                    ctx.scale(this.hitScale, this.hitScale);
                    ctx.translate(-this.x, -this.y);
                }
                
                const e = this.getEndpoints();
                
                // Shadow
                ctx.beginPath(); 
                ctx.moveTo(e.a.x + 2, e.a.y + 3); 
                ctx.lineTo(e.b.x + 2, e.b.y + 3);
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.lineWidth = 5;
                ctx.lineCap = 'round';
                ctx.stroke();
                
                // Selection glow
                if (this.isSelected) {
                    ctx.shadowColor = THEME.shapeSelectedGlow;
                    ctx.shadowBlur = 20;
                }
                
                // Hit highlight glow
                if (this.hitHighlight > 0) {
                    ctx.shadowColor = THEME.shapeHitHighlight;
                    ctx.shadowBlur = 25 * this.hitHighlight;
                }
                
                // Main line
                ctx.beginPath(); ctx.moveTo(e.a.x, e.a.y); ctx.lineTo(e.b.x, e.b.y);
                ctx.strokeStyle = colors.stroke; 
                ctx.lineWidth = this.isSelected ? 5 : 3.5;
                ctx.lineCap = 'round'; ctx.stroke();
                ctx.shadowBlur = 0;
                
                // Endpoints
                [e.a, e.b].forEach(p => {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, this.isSelected ? 6 : 4, 0, Math.PI * 2);
                    ctx.fillStyle = colors.stroke;
                    ctx.fill();
                });
                
                // NOTE: LineSegment cannot be one-way (oneWayEligible = false)
                // So no one-way highlight drawing needed here
                
                this.drawRotateHandle(ctx);
                const sideX = this.x + 20 * SIZE_SCALE;
                const sideY = this.y;
                this.drawHitCheck(ctx, sideX, sideY);
                ctx.restore();
            }
        }

        class HalfCircle extends Shape {
            constructor(x, y, radius = 40, colorIndex = 0) {
                super(x, y, colorIndex);
                this.radius = radius * SIZE_SCALE;
                this.shapeType = ShapeTypeEnum.HALF_CIRCLE;
                this.segments = 12;
                this.oneWayEnabled = false; // Enable one-way mode for Level 4+
            }
            getSegments() {
                const segs = [];
                // Curved segments (indices 0 to this.segments-1) - these are ACTIVE
                // Include arc center info for proper radial normal calculation
                for (let i = 0; i < this.segments; i++) {
                    const a1 = (i / this.segments) * Math.PI + this.rotation;
                    const a2 = ((i + 1) / this.segments) * Math.PI + this.rotation;
                    segs.push({
                        a: { x: this.x + Math.cos(a1) * this.radius, y: this.y + Math.sin(a1) * this.radius },
                        b: { x: this.x + Math.cos(a2) * this.radius, y: this.y + Math.sin(a2) * this.radius },
                        isActiveSide: true,  // Curved side bounces normally
                        isArc: true,         // Flag for radial normal calculation
                        arcCenter: { x: this.x, y: this.y },  // Circle center
                        arcRadius: this.radius
                    });
                }
                // Flat segment (index this.segments) - this is WRONG SIDE
                const startAngle = this.rotation, endAngle = this.rotation + Math.PI;
                segs.push({
                    a: { x: this.x + Math.cos(startAngle) * this.radius, y: this.y + Math.sin(startAngle) * this.radius },
                    b: { x: this.x + Math.cos(endAngle) * this.radius, y: this.y + Math.sin(endAngle) * this.radius },
                    isActiveSide: false  // Flat side triggers vanish in one-way mode
                });
                return segs;
            }
            containsPoint(px, py) {
                const dist = Math.sqrt((px - this.x)**2 + (py - this.y)**2);
                return dist < this.radius + 12;
            }
            clampToCanvas(w, h, bottomLimit) {
                const margin = 10;
                this.x = Utils.clamp(this.x, this.radius + margin, w - this.radius - margin);
                this.y = Utils.clamp(this.y, this.radius + margin, bottomLimit - this.radius - margin);
            }
            draw(ctx, isActive = false) {
                if (!this.isVisible()) return;
                ctx.save();
                ctx.globalAlpha = this.opacity;
                
                const colors = this.getColors();
                
                // Apply hit scale
                if (this.hitScale !== 1) {
                    ctx.translate(this.x, this.y);
                    ctx.scale(this.hitScale, this.hitScale);
                    ctx.translate(-this.x, -this.y);
                }
                
                // Shadow
                ctx.beginPath();
                ctx.arc(this.x + 2, this.y + 3, this.radius, this.rotation, this.rotation + Math.PI);
                ctx.closePath();
                ctx.fillStyle = 'rgba(0, 0, 0, 0.25)';
                ctx.fill();
                
                // Selection glow
                if (this.isSelected) {
                    ctx.shadowColor = THEME.shapeSelectedGlow;
                    ctx.shadowBlur = 20;
                }
                
                // Main shape fill
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, this.rotation, this.rotation + Math.PI);
                ctx.closePath();
                ctx.fillStyle = colors.fill;
                ctx.fill();
                
                // Hit highlight glow
                if (this.hitHighlight > 0) {
                    ctx.shadowColor = THEME.shapeHitHighlight;
                    ctx.shadowBlur = 25 * this.hitHighlight;
                }
                
                // Draw curved edge with one-way highlight if enabled
                if (this.oneWayEnabled) {
                    // Draw flat side with normal stroke
                    ctx.beginPath();
                    const startAngle = this.rotation, endAngle = this.rotation + Math.PI;
                    ctx.moveTo(this.x + Math.cos(startAngle) * this.radius, this.y + Math.sin(startAngle) * this.radius);
                    ctx.lineTo(this.x + Math.cos(endAngle) * this.radius, this.y + Math.sin(endAngle) * this.radius);
                    ctx.strokeStyle = colors.stroke;
                    ctx.lineWidth = this.isSelected ? 3.5 : 2;
                    ctx.stroke();
                    
                    // Draw curved side with one-way highlight (NO shadow/glow)
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, this.rotation, this.rotation + Math.PI);
                    ctx.strokeStyle = THEME.oneWayHighlight;
                    ctx.lineWidth = this.isSelected ? 4.5 : 3;
                    ctx.shadowBlur = 0;
                    ctx.shadowColor = 'transparent';
                    ctx.stroke();
                } else {
                    // Normal stroke for both sides
                    ctx.strokeStyle = colors.stroke;
                    ctx.lineWidth = this.isSelected ? 3.5 : 2;
                    ctx.stroke();
                }
                ctx.shadowBlur = 0;
                
                this.drawRotateHandle(ctx);
                this.drawHitCheck(ctx, this.x, this.y);
                ctx.restore();
            }
        }

        // ========================================
        // NEW SHAPES - Diamond, Octagon, Trapezoid
        // ========================================
        
        class Diamond extends Shape {
            constructor(x, y, width = 50, height = 70, colorIndex = 0) {
                super(x, y, colorIndex);
                this.width = width * SIZE_SCALE;
                this.height = height * SIZE_SCALE;
                this.shapeType = ShapeTypeEnum.DIAMOND;
            }
            getLocalVertices() {
                const hw = this.width / 2, hh = this.height / 2;
                return [
                    { x: 0, y: -hh },    // top
                    { x: hw, y: 0 },     // right
                    { x: 0, y: hh },     // bottom
                    { x: -hw, y: 0 }     // left
                ];
            }
            getVertices() {
                const local = this.getLocalVertices(), center = { x: this.x, y: this.y };
                return local.map(v => this.rotatePoint({ x: center.x + v.x, y: center.y + v.y }, center, this.rotation));
            }
            getSegments() {
                const v = this.getVertices();
                return [
                    { a: v[0], b: v[1] },
                    { a: v[1], b: v[2] },
                    { a: v[2], b: v[3] },
                    { a: v[3], b: v[0] }
                ];
            }
            containsPoint(px, py) {
                const v = this.getVertices();
                // Point in convex polygon test
                let positive = 0, negative = 0;
                for (let i = 0; i < v.length; i++) {
                    const p1 = v[i], p2 = v[(i + 1) % v.length];
                    const cross = (px - p1.x) * (p2.y - p1.y) - (py - p1.y) * (p2.x - p1.x);
                    if (cross > 0) positive++;
                    else if (cross < 0) negative++;
                }
                return positive === 0 || negative === 0;
            }
            clampToCanvas(w, h, bottomLimit) {
                const margin = 10, halfSize = Math.max(this.width, this.height) / 2 + 10;
                this.x = Utils.clamp(this.x, halfSize + margin, w - halfSize - margin);
                this.y = Utils.clamp(this.y, halfSize + margin, bottomLimit - halfSize - margin);
            }
            draw(ctx, isActive = false) {
                if (!this.isVisible()) return;
                ctx.save();
                ctx.globalAlpha = this.opacity;
                
                const colors = this.getColors();
                
                if (this.hitScale !== 1) {
                    ctx.translate(this.x, this.y);
                    ctx.scale(this.hitScale, this.hitScale);
                    ctx.translate(-this.x, -this.y);
                }
                
                const v = this.getVertices();
                
                // Shadow
                ctx.beginPath();
                ctx.moveTo(v[0].x + 2, v[0].y + 3);
                for (let i = 1; i < v.length; i++) ctx.lineTo(v[i].x + 2, v[i].y + 3);
                ctx.closePath();
                ctx.fillStyle = 'rgba(0, 0, 0, 0.25)';
                ctx.fill();
                
                if (this.isSelected) {
                    ctx.shadowColor = THEME.shapeSelectedGlow;
                    ctx.shadowBlur = 20;
                }
                
                // Main shape
                ctx.beginPath();
                ctx.moveTo(v[0].x, v[0].y);
                for (let i = 1; i < v.length; i++) ctx.lineTo(v[i].x, v[i].y);
                ctx.closePath();
                ctx.fillStyle = colors.fill;
                ctx.fill();
                
                if (this.hitHighlight > 0) {
                    ctx.shadowColor = THEME.shapeHitHighlight;
                    ctx.shadowBlur = 25 * this.hitHighlight;
                }
                
                ctx.strokeStyle = colors.stroke;
                ctx.lineWidth = this.isSelected ? 3.5 : 2;
                ctx.lineJoin = 'round';
                ctx.stroke();
                ctx.shadowBlur = 0;
                
                this.drawOneWayHighlight(ctx);
                
                this.drawRotateHandle(ctx);
                this.drawHitCheck(ctx, this.x, this.y);
                ctx.restore();
            }
        }

        class Octagon extends Shape {
            constructor(x, y, radius = 35, colorIndex = 0) {
                super(x, y, colorIndex);
                this.radius = radius * SIZE_SCALE;
                this.shapeType = ShapeTypeEnum.OCTAGON;
            }
            getLocalVertices() {
                const verts = [];
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2 - Math.PI / 2; // Start from top
                    verts.push({
                        x: Math.cos(angle) * this.radius,
                        y: Math.sin(angle) * this.radius
                    });
                }
                return verts;
            }
            getVertices() {
                const local = this.getLocalVertices(), center = { x: this.x, y: this.y };
                return local.map(v => this.rotatePoint({ x: center.x + v.x, y: center.y + v.y }, center, this.rotation));
            }
            getSegments() {
                const v = this.getVertices();
                const segs = [];
                for (let i = 0; i < v.length; i++) {
                    segs.push({ a: v[i], b: v[(i + 1) % v.length] });
                }
                return segs;
            }
            containsPoint(px, py) {
                const v = this.getVertices();
                let positive = 0, negative = 0;
                for (let i = 0; i < v.length; i++) {
                    const p1 = v[i], p2 = v[(i + 1) % v.length];
                    const cross = (px - p1.x) * (p2.y - p1.y) - (py - p1.y) * (p2.x - p1.x);
                    if (cross > 0) positive++;
                    else if (cross < 0) negative++;
                }
                return positive === 0 || negative === 0;
            }
            clampToCanvas(w, h, bottomLimit) {
                const margin = 10;
                this.x = Utils.clamp(this.x, this.radius + margin, w - this.radius - margin);
                this.y = Utils.clamp(this.y, this.radius + margin, bottomLimit - this.radius - margin);
            }
            draw(ctx, isActive = false) {
                if (!this.isVisible()) return;
                ctx.save();
                ctx.globalAlpha = this.opacity;
                
                const colors = this.getColors();
                
                if (this.hitScale !== 1) {
                    ctx.translate(this.x, this.y);
                    ctx.scale(this.hitScale, this.hitScale);
                    ctx.translate(-this.x, -this.y);
                }
                
                const v = this.getVertices();
                
                // Shadow
                ctx.beginPath();
                ctx.moveTo(v[0].x + 2, v[0].y + 3);
                for (let i = 1; i < v.length; i++) ctx.lineTo(v[i].x + 2, v[i].y + 3);
                ctx.closePath();
                ctx.fillStyle = 'rgba(0, 0, 0, 0.25)';
                ctx.fill();
                
                if (this.isSelected) {
                    ctx.shadowColor = THEME.shapeSelectedGlow;
                    ctx.shadowBlur = 20;
                }
                
                // Main shape
                ctx.beginPath();
                ctx.moveTo(v[0].x, v[0].y);
                for (let i = 1; i < v.length; i++) ctx.lineTo(v[i].x, v[i].y);
                ctx.closePath();
                ctx.fillStyle = colors.fill;
                ctx.fill();
                
                if (this.hitHighlight > 0) {
                    ctx.shadowColor = THEME.shapeHitHighlight;
                    ctx.shadowBlur = 25 * this.hitHighlight;
                }
                
                ctx.strokeStyle = colors.stroke;
                ctx.lineWidth = this.isSelected ? 3.5 : 2;
                ctx.lineJoin = 'round';
                ctx.stroke();
                ctx.shadowBlur = 0;
                
                this.drawOneWayHighlight(ctx);
                
                this.drawRotateHandle(ctx);
                this.drawHitCheck(ctx, this.x, this.y);
                ctx.restore();
            }
        }

        class Trapezoid extends Shape {
            constructor(x, y, topWidth = 40, bottomWidth = 70, height = 50, colorIndex = 0) {
                super(x, y, colorIndex);
                this.topWidth = topWidth * SIZE_SCALE;
                this.bottomWidth = bottomWidth * SIZE_SCALE;
                this.height = height * SIZE_SCALE;
                this.shapeType = ShapeTypeEnum.TRAPEZOID;
            }
            getLocalVertices() {
                const ht = this.topWidth / 2, hb = this.bottomWidth / 2, hh = this.height / 2;
                return [
                    { x: -ht, y: -hh },  // top-left
                    { x: ht, y: -hh },   // top-right
                    { x: hb, y: hh },    // bottom-right
                    { x: -hb, y: hh }    // bottom-left
                ];
            }
            getVertices() {
                const local = this.getLocalVertices(), center = { x: this.x, y: this.y };
                return local.map(v => this.rotatePoint({ x: center.x + v.x, y: center.y + v.y }, center, this.rotation));
            }
            getSegments() {
                const v = this.getVertices();
                return [
                    { a: v[0], b: v[1] },
                    { a: v[1], b: v[2] },
                    { a: v[2], b: v[3] },
                    { a: v[3], b: v[0] }
                ];
            }
            containsPoint(px, py) {
                const v = this.getVertices();
                let positive = 0, negative = 0;
                for (let i = 0; i < v.length; i++) {
                    const p1 = v[i], p2 = v[(i + 1) % v.length];
                    const cross = (px - p1.x) * (p2.y - p1.y) - (py - p1.y) * (p2.x - p1.x);
                    if (cross > 0) positive++;
                    else if (cross < 0) negative++;
                }
                return positive === 0 || negative === 0;
            }
            clampToCanvas(w, h, bottomLimit) {
                const margin = 10, halfSize = Math.max(this.bottomWidth, this.height) / 2 + 10;
                this.x = Utils.clamp(this.x, halfSize + margin, w - halfSize - margin);
                this.y = Utils.clamp(this.y, halfSize + margin, bottomLimit - halfSize - margin);
            }
            draw(ctx, isActive = false) {
                if (!this.isVisible()) return;
                ctx.save();
                ctx.globalAlpha = this.opacity;
                
                const colors = this.getColors();
                
                if (this.hitScale !== 1) {
                    ctx.translate(this.x, this.y);
                    ctx.scale(this.hitScale, this.hitScale);
                    ctx.translate(-this.x, -this.y);
                }
                
                const v = this.getVertices();
                
                // Shadow
                ctx.beginPath();
                ctx.moveTo(v[0].x + 2, v[0].y + 3);
                for (let i = 1; i < v.length; i++) ctx.lineTo(v[i].x + 2, v[i].y + 3);
                ctx.closePath();
                ctx.fillStyle = 'rgba(0, 0, 0, 0.25)';
                ctx.fill();
                
                if (this.isSelected) {
                    ctx.shadowColor = THEME.shapeSelectedGlow;
                    ctx.shadowBlur = 20;
                }
                
                // Main shape
                ctx.beginPath();
                ctx.moveTo(v[0].x, v[0].y);
                for (let i = 1; i < v.length; i++) ctx.lineTo(v[i].x, v[i].y);
                ctx.closePath();
                ctx.fillStyle = colors.fill;
                ctx.fill();
                
                if (this.hitHighlight > 0) {
                    ctx.shadowColor = THEME.shapeHitHighlight;
                    ctx.shadowBlur = 25 * this.hitHighlight;
                }
                
                ctx.strokeStyle = colors.stroke;
                ctx.lineWidth = this.isSelected ? 3.5 : 2;
                ctx.lineJoin = 'round';
                ctx.stroke();
                ctx.shadowBlur = 0;
                
                this.drawOneWayHighlight(ctx);
                
                this.drawRotateHandle(ctx);
                this.drawHitCheck(ctx, this.x, this.y);
                ctx.restore();
            }
        }

        // ========================================
        // LEVEL 3 SHAPES - Arrowhead, Boomerang, HalfPipe, SawtoothRamp
        // ========================================

        class Arrowhead extends Shape {
            // Concave dart/arrowhead shape pointing up (+25% larger)
            constructor(x, y, width = 63, height = 75, colorIndex = 0) {
                super(x, y, colorIndex);
                this.width = width * SIZE_SCALE;
                this.height = height * SIZE_SCALE;
                this.shapeType = ShapeTypeEnum.ARROWHEAD;
            }
            getLocalVertices() {
                const hw = this.width / 2, hh = this.height / 2;
                const notchDepth = this.height * 0.35; // Concave notch
                return [
                    { x: 0, y: -hh },           // tip (top)
                    { x: hw, y: hh },           // bottom-right
                    { x: 0, y: hh - notchDepth }, // notch (concave point)
                    { x: -hw, y: hh }           // bottom-left
                ];
            }
            getVertices() {
                const local = this.getLocalVertices(), center = { x: this.x, y: this.y };
                return local.map(v => this.rotatePoint({ x: center.x + v.x, y: center.y + v.y }, center, this.rotation));
            }
            getSegments() {
                const v = this.getVertices();
                return [
                    { a: v[0], b: v[1] },
                    { a: v[1], b: v[2] },
                    { a: v[2], b: v[3] },
                    { a: v[3], b: v[0] }
                ];
            }
            containsPoint(px, py) {
                // Point-in-polygon test for concave polygon using ray casting
                const v = this.getVertices();
                let inside = false;
                for (let i = 0, j = v.length - 1; i < v.length; j = i++) {
                    const xi = v[i].x, yi = v[i].y;
                    const xj = v[j].x, yj = v[j].y;
                    if (((yi > py) !== (yj > py)) && (px < (xj - xi) * (py - yi) / (yj - yi) + xi)) {
                        inside = !inside;
                    }
                }
                return inside;
            }
            clampToCanvas(w, h, bottomLimit) {
                const margin = 10, halfSize = Math.max(this.width, this.height) / 2 + 10;
                this.x = Utils.clamp(this.x, halfSize + margin, w - halfSize - margin);
                this.y = Utils.clamp(this.y, halfSize + margin, bottomLimit - halfSize - margin);
            }
            draw(ctx, isActive = false) {
                if (!this.isVisible()) return;
                ctx.save();
                ctx.globalAlpha = this.opacity;
                const colors = this.getColors();
                
                if (this.hitScale !== 1) {
                    ctx.translate(this.x, this.y);
                    ctx.scale(this.hitScale, this.hitScale);
                    ctx.translate(-this.x, -this.y);
                }
                
                const v = this.getVertices();
                
                // Shadow
                ctx.beginPath();
                ctx.moveTo(v[0].x + 2, v[0].y + 3);
                for (let i = 1; i < v.length; i++) ctx.lineTo(v[i].x + 2, v[i].y + 3);
                ctx.closePath();
                ctx.fillStyle = 'rgba(0, 0, 0, 0.25)';
                ctx.fill();
                
                if (this.isSelected) {
                    ctx.shadowColor = THEME.shapeSelectedGlow;
                    ctx.shadowBlur = 20;
                }
                
                ctx.beginPath();
                ctx.moveTo(v[0].x, v[0].y);
                for (let i = 1; i < v.length; i++) ctx.lineTo(v[i].x, v[i].y);
                ctx.closePath();
                ctx.fillStyle = colors.fill;
                ctx.fill();
                
                if (this.hitHighlight > 0) {
                    ctx.shadowColor = THEME.shapeHitHighlight;
                    ctx.shadowBlur = 25 * this.hitHighlight;
                }
                
                ctx.strokeStyle = colors.stroke;
                ctx.lineWidth = this.isSelected ? 3.5 : 2;
                ctx.lineJoin = 'round';
                ctx.stroke();
                ctx.shadowBlur = 0;
                
                this.drawOneWayHighlight(ctx);
                
                this.drawRotateHandle(ctx);
                this.drawHitCheck(ctx, this.x, this.y);
                ctx.restore();
            }
        }

        class Boomerang extends Shape {
            // Thick V-shaped boomerang
            // armLength=76 gives outer edge length = 70 (matching triangle side)
            constructor(x, y, armLength = 76, armWidth = 15, angle = 70, colorIndex = 0) {
                super(x, y, colorIndex);
                this.armLength = armLength * SIZE_SCALE;
                this.armWidth = armWidth * SIZE_SCALE;
                this.armAngle = angle * Math.PI / 180;
                this.shapeType = ShapeTypeEnum.BOOMERANG;
            }
            getLocalVertices() {
                // Original geometry formula - only armLength changed
                const len = this.armLength, w = this.armWidth;
                const halfAngle = this.armAngle / 2;
                return [
                    // v0: Left arm outer tip
                    { x: -Math.sin(halfAngle) * len, y: -Math.cos(halfAngle) * len },
                    // v1: Center top (outer apex)
                    { x: 0, y: -w * 0.5 },
                    // v2: Right arm outer tip
                    { x: Math.sin(halfAngle) * len, y: -Math.cos(halfAngle) * len },
                    // v3: Right arm inner tip
                    { x: Math.sin(halfAngle) * (len - w), y: -Math.cos(halfAngle) * (len - w) + w * 0.3 },
                    // v4: Center bottom (inner)
                    { x: 0, y: w * 0.8 },
                    // v5: Left arm inner tip
                    { x: -Math.sin(halfAngle) * (len - w), y: -Math.cos(halfAngle) * (len - w) + w * 0.3 }
                ];
            }
            getVertices() {
                const local = this.getLocalVertices(), center = { x: this.x, y: this.y };
                return local.map(v => this.rotatePoint({ x: center.x + v.x, y: center.y + v.y }, center, this.rotation));
            }
            getSegments() {
                const v = this.getVertices();
                const segs = [];
                for (let i = 0; i < v.length; i++) {
                    segs.push({ a: v[i], b: v[(i + 1) % v.length] });
                }
                return segs;
            }
            containsPoint(px, py) {
                const v = this.getVertices();
                let inside = false;
                for (let i = 0, j = v.length - 1; i < v.length; j = i++) {
                    const xi = v[i].x, yi = v[i].y;
                    const xj = v[j].x, yj = v[j].y;
                    if (((yi > py) !== (yj > py)) && (px < (xj - xi) * (py - yi) / (yj - yi) + xi)) {
                        inside = !inside;
                    }
                }
                return inside;
            }
            clampToCanvas(w, h, bottomLimit) {
                const margin = 10, halfSize = this.armLength + 10;
                this.x = Utils.clamp(this.x, halfSize + margin, w - halfSize - margin);
                this.y = Utils.clamp(this.y, halfSize + margin, bottomLimit - halfSize - margin);
            }
            draw(ctx, isActive = false) {
                if (!this.isVisible()) return;
                ctx.save();
                ctx.globalAlpha = this.opacity;
                const colors = this.getColors();
                
                if (this.hitScale !== 1) {
                    ctx.translate(this.x, this.y);
                    ctx.scale(this.hitScale, this.hitScale);
                    ctx.translate(-this.x, -this.y);
                }
                
                const v = this.getVertices();
                
                ctx.beginPath();
                ctx.moveTo(v[0].x + 2, v[0].y + 3);
                for (let i = 1; i < v.length; i++) ctx.lineTo(v[i].x + 2, v[i].y + 3);
                ctx.closePath();
                ctx.fillStyle = 'rgba(0, 0, 0, 0.25)';
                ctx.fill();
                
                if (this.isSelected) {
                    ctx.shadowColor = THEME.shapeSelectedGlow;
                    ctx.shadowBlur = 20;
                }
                
                ctx.beginPath();
                ctx.moveTo(v[0].x, v[0].y);
                for (let i = 1; i < v.length; i++) ctx.lineTo(v[i].x, v[i].y);
                ctx.closePath();
                ctx.fillStyle = colors.fill;
                ctx.fill();
                
                if (this.hitHighlight > 0) {
                    ctx.shadowColor = THEME.shapeHitHighlight;
                    ctx.shadowBlur = 25 * this.hitHighlight;
                }
                
                ctx.strokeStyle = colors.stroke;
                ctx.lineWidth = this.isSelected ? 3.5 : 2;
                ctx.lineJoin = 'round';
                ctx.stroke();
                ctx.shadowBlur = 0;
                
                this.drawOneWayHighlight(ctx);
                
                this.drawRotateHandle(ctx);
                this.drawHitCheck(ctx, this.x, this.y);
                ctx.restore();
            }
        }

        class HalfPipe extends Shape {
            // U-shaped channel/half pipe (+25% larger)
            constructor(x, y, width = 75, height = 56, wallThickness = 12, colorIndex = 0) {
                super(x, y, colorIndex);
                this.width = width * SIZE_SCALE;
                this.height = height * SIZE_SCALE;
                this.wallThickness = wallThickness * SIZE_SCALE;
                this.shapeType = ShapeTypeEnum.HALF_PIPE;
            }
            getLocalVertices() {
                const hw = this.width / 2, hh = this.height / 2;
                const wt = this.wallThickness;
                // U shape: outer boundary then inner boundary (forms thick U)
                return [
                    // Outer U (clockwise)
                    { x: -hw, y: -hh },           // top-left outer [0]
                    { x: -hw, y: hh },            // bottom-left outer [1]
                    { x: hw, y: hh },             // bottom-right outer [2]
                    { x: hw, y: -hh },            // top-right outer [3]
                    // Inner cutout
                    { x: hw - wt, y: -hh },       // top-right inner [4]
                    { x: hw - wt, y: hh - wt },   // bottom-right inner [5]
                    { x: -hw + wt, y: hh - wt },  // bottom-left inner [6]
                    { x: -hw + wt, y: -hh }       // top-left inner [7]
                ];
            }
            getVertices() {
                const local = this.getLocalVertices(), center = { x: this.x, y: this.y };
                return local.map(v => this.rotatePoint({ x: center.x + v.x, y: center.y + v.y }, center, this.rotation));
            }
            getSegments() {
                const v = this.getVertices();
                // Only return the inside surfaces (walls and floor) that ball can hit
                return [
                    // Left inner wall
                    { a: v[7], b: v[6] },
                    // Bottom inner floor
                    { a: v[6], b: v[5] },
                    // Right inner wall
                    { a: v[5], b: v[4] },
                    // Outer segments for collision from outside
                    { a: v[0], b: v[1] },  // left outer
                    { a: v[1], b: v[2] },  // bottom outer
                    { a: v[2], b: v[3] },  // right outer
                    // Top edges
                    { a: v[0], b: v[7] },  // top-left cap
                    { a: v[4], b: v[3] }   // top-right cap
                ];
            }
            containsPoint(px, py) {
                // Use outer rectangular bounds for easier selection
                const v = this.getVertices();
                return this.pointInQuad(px, py, v[0], v[1], v[2], v[3]);
            }
            pointInQuad(px, py, v0, v1, v2, v3) {
                const verts = [v0, v1, v2, v3];
                let inside = false;
                for (let i = 0, j = 3; i < 4; j = i++) {
                    const xi = verts[i].x, yi = verts[i].y;
                    const xj = verts[j].x, yj = verts[j].y;
                    if (((yi > py) !== (yj > py)) && (px < (xj - xi) * (py - yi) / (yj - yi) + xi)) {
                        inside = !inside;
                    }
                }
                return inside;
            }
            clampToCanvas(w, h, bottomLimit) {
                const margin = 10, halfSize = Math.max(this.width, this.height) / 2 + 10;
                this.x = Utils.clamp(this.x, halfSize + margin, w - halfSize - margin);
                this.y = Utils.clamp(this.y, halfSize + margin, bottomLimit - halfSize - margin);
            }
            draw(ctx, isActive = false) {
                if (!this.isVisible()) return;
                ctx.save();
                ctx.globalAlpha = this.opacity;
                const colors = this.getColors();
                
                if (this.hitScale !== 1) {
                    ctx.translate(this.x, this.y);
                    ctx.scale(this.hitScale, this.hitScale);
                    ctx.translate(-this.x, -this.y);
                }
                
                const v = this.getVertices();
                
                // Shadow for U-frame
                ctx.beginPath();
                ctx.moveTo(v[0].x + 2, v[0].y + 3);
                ctx.lineTo(v[1].x + 2, v[1].y + 3);
                ctx.lineTo(v[2].x + 2, v[2].y + 3);
                ctx.lineTo(v[3].x + 2, v[3].y + 3);
                ctx.lineTo(v[4].x + 2, v[4].y + 3);
                ctx.lineTo(v[5].x + 2, v[5].y + 3);
                ctx.lineTo(v[6].x + 2, v[6].y + 3);
                ctx.lineTo(v[7].x + 2, v[7].y + 3);
                ctx.closePath();
                ctx.fillStyle = 'rgba(0, 0, 0, 0.25)';
                ctx.fill('evenodd');
                
                if (this.isSelected) {
                    ctx.shadowColor = THEME.shapeSelectedGlow;
                    ctx.shadowBlur = 20;
                }
                
                // Draw U shape with hollow interior using evenodd fill rule
                ctx.beginPath();
                // Outer boundary (clockwise)
                ctx.moveTo(v[0].x, v[0].y);
                ctx.lineTo(v[1].x, v[1].y);
                ctx.lineTo(v[2].x, v[2].y);
                ctx.lineTo(v[3].x, v[3].y);
                ctx.closePath();
                // Inner cutout (counter-clockwise for evenodd)
                ctx.moveTo(v[7].x, v[7].y);
                ctx.lineTo(v[6].x, v[6].y);
                ctx.lineTo(v[5].x, v[5].y);
                ctx.lineTo(v[4].x, v[4].y);
                ctx.closePath();
                
                ctx.fillStyle = colors.fill;
                ctx.fill('evenodd');
                
                if (this.hitHighlight > 0) {
                    ctx.shadowColor = THEME.shapeHitHighlight;
                    ctx.shadowBlur = 25 * this.hitHighlight;
                }
                
                // Stroke each edge separately to avoid closing line across gap
                ctx.strokeStyle = colors.stroke;
                ctx.lineWidth = this.isSelected ? 3.5 : 2;
                ctx.lineJoin = 'round';
                ctx.lineCap = 'round';
                
                // Left outer wall
                ctx.beginPath(); ctx.moveTo(v[0].x, v[0].y); ctx.lineTo(v[1].x, v[1].y); ctx.stroke();
                // Bottom outer
                ctx.beginPath(); ctx.moveTo(v[1].x, v[1].y); ctx.lineTo(v[2].x, v[2].y); ctx.stroke();
                // Right outer wall
                ctx.beginPath(); ctx.moveTo(v[2].x, v[2].y); ctx.lineTo(v[3].x, v[3].y); ctx.stroke();
                // Top-right cap
                ctx.beginPath(); ctx.moveTo(v[3].x, v[3].y); ctx.lineTo(v[4].x, v[4].y); ctx.stroke();
                // Right inner wall
                ctx.beginPath(); ctx.moveTo(v[4].x, v[4].y); ctx.lineTo(v[5].x, v[5].y); ctx.stroke();
                // Bottom inner
                ctx.beginPath(); ctx.moveTo(v[5].x, v[5].y); ctx.lineTo(v[6].x, v[6].y); ctx.stroke();
                // Left inner wall
                ctx.beginPath(); ctx.moveTo(v[6].x, v[6].y); ctx.lineTo(v[7].x, v[7].y); ctx.stroke();
                // Top-left cap
                ctx.beginPath(); ctx.moveTo(v[7].x, v[7].y); ctx.lineTo(v[0].x, v[0].y); ctx.stroke();
                
                ctx.shadowBlur = 0;
                
                this.drawOneWayHighlight(ctx);
                
                this.drawRotateHandle(ctx);
                this.drawHitCheck(ctx, this.x, this.y);
                ctx.restore();
            }
        }

        class SawtoothRamp extends Shape {
            // Diagonal ramp with sawtooth teeth along one edge
            constructor(x, y, width = 70, height = 50, teethCount = 6, colorIndex = 0) {
                super(x, y, colorIndex);
                this.width = width * SIZE_SCALE;
                this.height = height * SIZE_SCALE;
                this.teethCount = teethCount;
                this.toothHeight = 8 * SIZE_SCALE;
                this.shapeType = ShapeTypeEnum.SAWTOOTH_RAMP;
            }
            getLocalVertices() {
                const hw = this.width / 2, hh = this.height / 2;
                const verts = [];
                
                // Start from top-left, go clockwise
                verts.push({ x: -hw, y: -hh }); // top-left
                
                // Sawtooth edge along the top (from left to right)
                const toothWidth = this.width / this.teethCount;
                for (let i = 0; i < this.teethCount; i++) {
                    const baseX = -hw + i * toothWidth;
                    // Tooth peak
                    verts.push({ x: baseX + toothWidth * 0.5, y: -hh - this.toothHeight });
                    // Tooth valley (or end)
                    if (i < this.teethCount - 1) {
                        verts.push({ x: baseX + toothWidth, y: -hh });
                    }
                }
                
                // Top-right corner
                verts.push({ x: hw, y: -hh });
                // Bottom-right
                verts.push({ x: hw, y: hh });
                // Bottom-left
                verts.push({ x: -hw, y: hh });
                
                return verts;
            }
            getVertices() {
                const local = this.getLocalVertices(), center = { x: this.x, y: this.y };
                return local.map(v => this.rotatePoint({ x: center.x + v.x, y: center.y + v.y }, center, this.rotation));
            }
            getSegments() {
                const v = this.getVertices();
                const segs = [];
                
                // SAWTOOTH_RAMP side indices:
                // Side 0 = ALL teeth segments (top edge - multiple segments)
                // Side 1 = right edge (single segment)
                // Side 2 = bottom edge (single segment)
                // Side 3 = left edge (single segment)
                
                // Calculate how many vertices are in the teeth section
                // Structure: top-left (1) + teeth peaks/valleys (teethCount*2 - 1) + top-right (1) + bottom-right (1) + bottom-left (1)
                // Teeth segments: from vertex 0 to vertex (teethCount*2) which is top-right corner
                const teethEndVertex = this.teethCount * 2;  // Index of top-right corner
                
                for (let i = 0; i < v.length; i++) {
                    const seg = { a: v[i], b: v[(i + 1) % v.length] };
                    
                    // Assign sideIndex based on which logical side this segment belongs to
                    if (i < teethEndVertex) {
                        // All tooth segments belong to side 0
                        seg.sideIndex = 0;
                    } else if (i === teethEndVertex) {
                        // Right edge (from top-right to bottom-right)
                        seg.sideIndex = 1;
                    } else if (i === teethEndVertex + 1) {
                        // Bottom edge (from bottom-right to bottom-left)
                        seg.sideIndex = 2;
                    } else {
                        // Left edge (from bottom-left to top-left)
                        seg.sideIndex = 3;
                    }
                    
                    segs.push(seg);
                }
                return segs;
            }
            containsPoint(px, py) {
                const v = this.getVertices();
                let inside = false;
                for (let i = 0, j = v.length - 1; i < v.length; j = i++) {
                    const xi = v[i].x, yi = v[i].y;
                    const xj = v[j].x, yj = v[j].y;
                    if (((yi > py) !== (yj > py)) && (px < (xj - xi) * (py - yi) / (yj - yi) + xi)) {
                        inside = !inside;
                    }
                }
                return inside;
            }
            clampToCanvas(w, h, bottomLimit) {
                const margin = 10, halfSize = Math.max(this.width, this.height) / 2 + this.toothHeight + 10;
                this.x = Utils.clamp(this.x, halfSize + margin, w - halfSize - margin);
                this.y = Utils.clamp(this.y, halfSize + margin, bottomLimit - halfSize - margin);
            }
            draw(ctx, isActive = false) {
                if (!this.isVisible()) return;
                ctx.save();
                ctx.globalAlpha = this.opacity;
                const colors = this.getColors();
                
                if (this.hitScale !== 1) {
                    ctx.translate(this.x, this.y);
                    ctx.scale(this.hitScale, this.hitScale);
                    ctx.translate(-this.x, -this.y);
                }
                
                const v = this.getVertices();
                
                // Shadow
                ctx.beginPath();
                ctx.moveTo(v[0].x + 2, v[0].y + 3);
                for (let i = 1; i < v.length; i++) ctx.lineTo(v[i].x + 2, v[i].y + 3);
                ctx.closePath();
                ctx.fillStyle = 'rgba(0, 0, 0, 0.25)';
                ctx.fill();
                
                if (this.isSelected) {
                    ctx.shadowColor = THEME.shapeSelectedGlow;
                    ctx.shadowBlur = 20;
                }
                
                ctx.beginPath();
                ctx.moveTo(v[0].x, v[0].y);
                for (let i = 1; i < v.length; i++) ctx.lineTo(v[i].x, v[i].y);
                ctx.closePath();
                ctx.fillStyle = colors.fill;
                ctx.fill();
                
                if (this.hitHighlight > 0) {
                    ctx.shadowColor = THEME.shapeHitHighlight;
                    ctx.shadowBlur = 25 * this.hitHighlight;
                }
                
                ctx.strokeStyle = colors.stroke;
                ctx.lineWidth = this.isSelected ? 3.5 : 2;
                ctx.lineJoin = 'round';
                ctx.stroke();
                ctx.shadowBlur = 0;
                
                this.drawOneWayHighlight(ctx);
                
                this.drawRotateHandle(ctx);
                this.drawHitCheck(ctx, this.x, this.y);
                ctx.restore();
            }
        }

        class Basket {
            constructor(x, y, radius = 35 * SIZE_SCALE) {
                this.x = x; this.y = y; 
                this.radius = radius;
                this.depth = 15 * SIZE_SCALE * 2;
                this.lidOpen = false;
                
                // Animation state
                this.lidOpenProgress = 0;  // 0 = closed, 1 = open
                this.targetLidOpen = false;
                this.pulseScale = 1;
                this.pulseTime = 0;
            }
            
            reset() {
                this.lidOpen = false;
                this.lidOpenProgress = 0;
                this.targetLidOpen = false;
                this.pulseScale = 1;
                this.pulseTime = 0;
            }
            
            openLid() {
                this.targetLidOpen = true;
                this.lidOpen = true; // For physics purposes
            }
            
            triggerWinPulse() {
                this.pulseScale = ANIM.successPulseScale;
                this.pulseTime = ANIM.basketPulseDuration;
            }
            
            update(dt) {
                // Animate lid opening with spring effect
                if (this.targetLidOpen && this.lidOpenProgress < 1) {
                    this.lidOpenProgress += dt * ANIM.lidOpenSpeed;
                    // Add slight overshoot for spring effect
                    if (this.lidOpenProgress > 1) {
                        this.lidOpenProgress = 1 + (this.lidOpenProgress - 1) * ANIM.lidBounce;
                    }
                    if (this.lidOpenProgress > 1.1) this.lidOpenProgress = 1;
                }
                
                // Decay pulse
                if (this.pulseTime > 0) {
                    this.pulseTime -= dt;
                    const t = this.pulseTime / ANIM.basketPulseDuration;
                    this.pulseScale = 1 + (ANIM.successPulseScale - 1) * t;
                } else {
                    this.pulseScale = 1;
                }
            }
            
            containsBall(ball, tolerance = 5) {
                if (!this.lidOpen) return false;
                const hw = this.radius;
                return ball.x > this.x - hw + ball.radius && ball.x < this.x + hw - ball.radius &&
                       ball.y > this.y && ball.y < this.y + this.depth - ball.radius + tolerance;
            }
            
            getSegments() {
                const hw = this.radius;
                const segments = [
                    { a: { x: this.x - hw, y: this.y }, b: { x: this.x - hw, y: this.y + this.depth } },
                    { a: { x: this.x + hw, y: this.y }, b: { x: this.x + hw, y: this.y + this.depth } },
                    { a: { x: this.x - hw, y: this.y + this.depth }, b: { x: this.x + hw, y: this.y + this.depth } }
                ];
                if (!this.lidOpen) {
                    segments.push({ a: { x: this.x - hw, y: this.y }, b: { x: this.x + hw, y: this.y } });
                }
                return segments;
            }
            
            draw(ctx) {
                const hw = this.radius;
                
                ctx.save();
                
                // Apply pulse scale
                if (this.pulseScale !== 1) {
                    ctx.translate(this.x, this.y + this.depth / 2);
                    ctx.scale(this.pulseScale, this.pulseScale);
                    ctx.translate(-this.x, -(this.y + this.depth / 2));
                }
                
                // Inner glow/fill
                ctx.beginPath();
                ctx.moveTo(this.x - hw, this.y);
                ctx.lineTo(this.x - hw, this.y + this.depth);
                ctx.lineTo(this.x + hw, this.y + this.depth);
                ctx.lineTo(this.x + hw, this.y);
                ctx.closePath();
                ctx.fillStyle = THEME.basketFill;
                ctx.fill();
                
                // Shadow
                ctx.beginPath();
                ctx.moveTo(this.x - hw + 2, this.y + 3);
                ctx.lineTo(this.x - hw + 2, this.y + this.depth + 3);
                ctx.lineTo(this.x + hw + 2, this.y + this.depth + 3);
                ctx.lineTo(this.x + hw + 2, this.y + 3);
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.12)';
                ctx.lineWidth = 4;
                ctx.stroke();
                
                // Basket body with colored rim
                ctx.beginPath();
                ctx.moveTo(this.x - hw, this.y);
                ctx.lineTo(this.x - hw, this.y + this.depth);
                ctx.lineTo(this.x + hw, this.y + this.depth);
                ctx.lineTo(this.x + hw, this.y);
                ctx.strokeStyle = THEME.basketStroke;
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.stroke();
                
                // Inner highlight
                ctx.beginPath();
                ctx.moveTo(this.x - hw + 3, this.y + 3);
                ctx.lineTo(this.x - hw + 3, this.y + this.depth - 3);
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.lineWidth = 1.5;
                ctx.stroke();
                
                // Lid (animated)
                if (this.lidOpenProgress < 1) {
                    const lidY = this.y - this.lidOpenProgress * 15;
                    const lidAlpha = 1 - this.lidOpenProgress;
                    
                    ctx.globalAlpha = lidAlpha;
                    ctx.shadowColor = THEME.basketLidGlow;
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.moveTo(this.x - hw, lidY);
                    ctx.lineTo(this.x + hw, lidY);
                    ctx.strokeStyle = THEME.basketLid;
                    ctx.lineWidth = 4;
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                    ctx.globalAlpha = 1;
                }
                
                ctx.restore();
            }
        }

        class Physics {
            constructor() { 
                this.gravity = BASE_GRAVITY; 
                this.restitution = 0.75; 
                this.friction = 0.90; 
                this.substeps = 4;
                this.collisionEvents = []; // Store collision events for VFX
                this.hasHadFirstCollision = false;  // Track if ball has had any collision yet
            }
            
            // Reset for new attempt
            resetCollisionTracking() {
                this.hasHadFirstCollision = false;
            }
            
            // Update physics parameters from level specs
            setLevelSpecs(gravityPreset, reboundPreset) {
                const gPreset = GRAVITY_PRESETS[gravityPreset];
                const rPreset = REBOUND_PRESETS[reboundPreset];
                this.gravity = BASE_GRAVITY * gPreset.multiplier;
                this.restitution = rPreset.restitution;
                this.friction = rPreset.friction;
            }
            
            update(ball, shapes, dt, basket = null) {
                this.collisionEvents = []; // Clear each frame
                this.wrongSideHitThisFrame = false;  // Track if wrong-side occurred
                
                // Skip collision processing if ball is vanishing
                if (ball.vanishing) {
                    ball.update(dt, this.gravity); // Still update vanish animation
                    return;
                }
                
                const subDt = dt / this.substeps;
                for (let i = 0; i < this.substeps; i++) {
                    ball.update(subDt, this.gravity);
                    
                    // Skip collisions if ball started vanishing during this frame
                    if (ball.vanishing) break;
                    
                    this.resolveShapeCollisions(ball, shapes);
                    
                    // Stop all substeps immediately if wrong-side hit occurred
                    if (this.wrongSideHitThisFrame) {
                        if (DEBUG_ONEWAY) console.log('[ONEWAY] Physics: wrong-side hit, stopping substeps');
                        break;
                    }
                    
                    if (basket) this.resolveBasketCollisions(ball, basket);
                }
            }
            
            resolveShapeCollisions(ball, shapes) {
                for (const shape of shapes) {
                    if (!shape.isVisible()) continue;
                    const segments = shape.getSegments();
                    for (let segIdx = 0; segIdx < segments.length; segIdx++) {
                        const seg = segments[segIdx];
                        // Use shared collision resolution
                        const collision = Utils.resolveSegmentCollision(
                            { x: ball.x, y: ball.y }, ball.radius, seg
                        );
                        if (!collision) continue;
                        
                        // Use SHARED one-way evaluator (same as preview)
                        const oneWayResult = Utils.evaluateOneWayCollision(shape, seg, segIdx);
                        
                        // One-way wrong-side ALWAYS causes vanish (first contact OR after rebound)
                        // The only difference is: X marker is shown in preview only for first contact
                        if (oneWayResult.shouldVanish) {
                            // Record wrong-side collision event for vanish
                            this.collisionEvents.push({
                                x: collision.closest.x,
                                y: collision.closest.y,
                                normalX: collision.normal.x,
                                normalY: collision.normal.y,
                                speed: 0,
                                isFirstHit: false,
                                isWrongSideHit: true  // Flag for game loop
                            });
                            this.wrongSideHitThisFrame = true;  // Signal to stop substeps
                            return; // Stop processing, ball will vanish
                        }
                        
                        // Mark that first collision has happened (for tracking purposes)
                        this.hasHadFirstCollision = true;
                        
                        // Push ball out of collision
                        ball.x += collision.normal.x * collision.penetration;
                        ball.y += collision.normal.y * collision.penetration;
                        
                        // Reflect velocity using shared function
                        const reflection = Utils.reflectVelocity(
                            { x: ball.vx, y: ball.vy },
                            collision.normal,
                            this.restitution,
                            this.friction
                        );
                        
                        if (reflection) {
                            ball.vx = reflection.vel.x;
                            ball.vy = reflection.vel.y;
                            
                            // Trigger squash/stretch effect
                            ball.onCollision(collision.normal.x, collision.normal.y, reflection.impactSpeed);
                            
                            // Record collision event for VFX
                            this.collisionEvents.push({
                                x: collision.closest.x,
                                y: collision.closest.y,
                                normalX: collision.normal.x,
                                normalY: collision.normal.y,
                                speed: reflection.impactSpeed,
                                isFirstHit: !shape.hasBeenHit
                            });
                            
                            if (!shape.hasBeenHit) {
                                shape.hasBeenHit = true;
                                shape.startDisappear();
                            }
                        }
                    }
                }
            }
            resolveBasketCollisions(ball, basket) {
                for (const seg of basket.getSegments()) {
                    // Use shared collision resolution
                    const collision = Utils.resolveSegmentCollision(
                        { x: ball.x, y: ball.y }, ball.radius, seg
                    );
                    if (!collision) continue;
                    
                    // Push ball out of collision
                    ball.x += collision.normal.x * collision.penetration;
                    ball.y += collision.normal.y * collision.penetration;
                    
                    // Reflect velocity using shared function
                    const reflection = Utils.reflectVelocity(
                        { x: ball.vx, y: ball.vy },
                        collision.normal,
                        this.restitution,
                        this.friction
                    );
                    
                    if (reflection) {
                        ball.vx = reflection.vel.x;
                        ball.vy = reflection.vel.y;
                        
                        // Trigger squash/stretch effect
                        ball.onCollision(collision.normal.x, collision.normal.y, reflection.impactSpeed);
                        
                        // Record collision event for VFX
                        this.collisionEvents.push({
                            x: collision.closest.x,
                            y: collision.closest.y,
                            normalX: collision.normal.x,
                            normalY: collision.normal.y,
                            speed: reflection.impactSpeed,
                            isFirstHit: false
                        });
                    }
                }
            }
        }

        class Game {
            constructor() {
                this.container = document.getElementById('game-container');
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.aspectRatio = 9 / 19.5;
                this.welcomeScreen = document.getElementById('welcome-screen');
                this.startBtn = document.getElementById('start-btn');
                this.debugOverlay = document.getElementById('debug-overlay');
                this.gameOverlay = document.getElementById('game-overlay');
                this.overlayText = document.getElementById('overlay-text');
                this.levelCompleteText = document.getElementById('level-complete-text');
                this.nextLevelBtn = document.getElementById('next-level-btn');
                this.retryBtn = document.getElementById('retry-btn');
                
                // Highest reached display elements
                this.highestReachedDisplay = document.getElementById('highest-reached-display');
                this.highestReachedValue = document.getElementById('highest-reached-value');
                
                // Powerup UI elements
                this.powerupOverlay = document.getElementById('powerup-overlay');
                this.powerupPopover = document.getElementById('powerup-popover');
                this.powerupUseBtn = document.getElementById('powerup-use-btn');
                
                // R Powerup UI elements
                this.rPowerupPopover = document.getElementById('r-powerup-popover');
                this.rPowerupUseBtn = document.getElementById('r-powerup-use-btn');
                this.removeSelectionOverlay = document.getElementById('remove-selection-overlay');
                
                // E Powerup UI elements
                this.ePowerupPopover = document.getElementById('e-powerup-popover');
                this.ePowerupUseBtn = document.getElementById('e-powerup-use-btn');
                
                this.gameStarted = false;
                this.level = 1; 
                this.lives = 5;
                this.initialLives = 5;
                this.state = 'edit'; 
                this.debugMode = false;
                this.hasSubmittedOnce = false;
                this.allShapesPlacedInitially = false;
                this.ball = null; 
                this.basket = null; 
                this.shapes = [];
                this.physics = new Physics();
                this.vfx = new VFXManager(); // VFX system
                this.selectedShape = null; 
                this.isRotating = false;
                this.dragOffset = { x: 0, y: 0 }; 
                this.lastTime = 0; 
                this.ballSpawnX = 0; 
                this.levelSeed = null;
                
                // Run progression tracking
                this.runHighestCompletedLevel = 0;
                
                this.gravityLevel = 'Normal';
                this.reboundLevel = 'Normal';
                
                this.isSwipingAngle = false;
                this.swipeStartX = 0;
                this.angleAtSwipeStart = 0;
                
                this.canSubmit = false;
                this.submitButtonGlow = 0;
                this.submitButtonPressed = false;
                this.angleBoxPressed = false;
                
                // Animation states
                this.hudAnimProgress = 0;
                this.time = 0;
                this.replaySwooshTime = 0; // For replay swoosh effect
                
                // HUD state transition
                this.hudStateOffset = 0; // Current offset for HUD slide
                this.targetHudOffset = 0; // Target offset based on state
                this.prevState = 'edit';
                
                // Submit button pop animation
                this.submitPopScale = 1;
                this.submitPopTime = 0;
                this.wasCanSubmit = false;
                
                // Trajectory powerup state
                this.trajectoryPowerupCount = 3;
                this.trajectoryExtended = false;
                this.powerupPopoverOpen = false;
                this.tUsedThisLevel = false;  // Per-level flag: true once T is used
                
                // Remove powerup state
                this.removePowerupCount = 3;
                this.rUsedThisLevel = false;  // Per-level flag: true once R is used
                this.rPopoverOpen = false;
                this.selectRemoveTargetMode = false;  // Object selection mode
                
                // Widen basket powerup state
                this.widenPowerupCount = 3;
                this.eUsedThisLevel = false;  // Per-level flag: true once E is used
                this.ePopoverOpen = false;
                this.basketWidened = false;  // Whether basket has been widened this level
                this.basketWidenProgress = 1;  // Animation progress (0->1)
                this.basketOriginalRadius = null;  // Store original radius for widening
                
                // ========================================
                // RUN-PERSISTENT MODIFIERS (Task B)
                // ========================================
                this.runModifiers = {
                    trajectoryMultiplier: 1,    // Default 1x, T powerup sets to 2x
                    basketWidthMultiplier: 1,   // Default 1x, E powerup sets to 1.3x
                    trajectoryPowerUsed: false, // True once T is used in this run
                    basketPowerUsed: false      // True once E is used in this run
                };
                
                // ========================================
                // FAIL QUEUE SYSTEM (Task A)
                // ========================================
                this.failQueued = false;
                this.failReason = null;  // 'OOB' | 'ONEWAY' | null
                this.failStartTime = 0;  // performance.now() timestamp
                this.attemptLifeCharged = false;  // Set true when submit() decrements life
                
                // One-way tutorial state
                this.tutorialActive = false;
                this.tutorialCallback = null;
                
                // ========================================
                // SAFARI TRANSITION STATE
                // Prevents freeze during level transitions
                // ========================================
                this.isTransitioning = false;      // Lock to prevent double-click
                this.pauseRender = false;          // Skip draw() during transition
                this.loopPausedForOverlay = false; // Stop RAF when overlay shown (Safari only)
                this.safariTimingInfo = '';        // Timing display for Safari debugging
                
                // Safari timing info element
                this.safariTimingElement = document.getElementById('safari-timing-info');
                
                // ========================================
                // LEVEL 1 INSTRUCTIONAL LABELS
                // ========================================
                this.level1DragLabelShown = false;      // Has drag instruction been shown
                this.level1PlacedOutside = false;       // Has user placed object outside piece area
                this.level1FirstSubmitDone = false;     // Has user clicked submit in level 1
                
                // Level 1 label DOM elements
                this.dragInstructionLabel = document.getElementById('drag-instruction-label');
                this.ballLineLabelContainer = document.getElementById('ball-line-label-container');
                this.basketLineLabelContainer = document.getElementById('basket-line-label-container');
                
                // Background pattern canvas
                this.patternCanvas = null;
                this.createBackgroundPattern();
                
                this.init();
            }
            
            createBackgroundPattern() {
                this.patternCanvas = document.createElement('canvas');
                this.patternCanvas.width = 24;
                this.patternCanvas.height = 24;
                const pctx = this.patternCanvas.getContext('2d');
                pctx.fillStyle = THEME.bgPattern;
                pctx.beginPath();
                pctx.arc(12, 12, 1.5, 0, Math.PI * 2);
                pctx.fill();
            }
            
            // ========================================
            // LEVEL 1 INSTRUCTIONAL LABELS
            // ========================================
            initLevel1Labels() {
                // Reset flags for level 1
                if (this.level !== 1) {
                    this.hideAllLevel1Labels();
                    return;
                }
                
                this.level1DragLabelShown = true;
                this.level1PlacedOutside = false;
                this.level1FirstSubmitDone = false;
                
                // Show labels
                this.dragInstructionLabel.classList.remove('hidden');
                this.ballLineLabelContainer.classList.remove('hidden');
                this.basketLineLabelContainer.classList.remove('hidden');
                
                // Position labels
                this.updateLevel1LabelPositions();
            }
            
            hideAllLevel1Labels() {
                this.dragInstructionLabel.classList.add('hidden');
                this.ballLineLabelContainer.classList.add('hidden');
                this.basketLineLabelContainer.classList.add('hidden');
            }
            
            updateLevel1LabelPositions() {
                if (this.level !== 1) return;
                
                const canvasRect = this.canvas.getBoundingClientRect();
                const scaleX = canvasRect.width / this.canvas.width;
                const scaleY = canvasRect.height / this.canvas.height;
                
                // Constants for label positioning
                const LABEL_LEFT_PADDING = 20;  // px from left edge
                const LABEL_LINE_GAP = 6;       // Symmetric gap above/below line (matches CSS)
                const LABEL_WIDTH_APPROX = 45;  // Approximate label width for collision
                const SAFETY_PADDING = 15;      // Extra padding to avoid ball/basket overlap
                
                // A) Position drag instruction label above piece area (centered, single line)
                if (!this.level1PlacedOutside) {
                    const pieceAreaTop = this.pieceAreaY * scaleY;
                    // CSS handles horizontal centering with left:50% + translateX(-50%)
                    this.dragInstructionLabel.style.top = `${pieceAreaTop - 25}px`;
                }
                
                // B) Position ball line and basket line labels on LEFT side
                if (!this.level1FirstSubmitDone) {
                    const labelLeftX = LABEL_LEFT_PADDING;
                    const labelRightEdge = labelLeftX + LABEL_WIDTH_APPROX;
                    const minBallBasketX = (labelRightEdge + SAFETY_PADDING) / scaleX;
                    
                    // Ball line label - centered vertically on the line
                    const ballLineY = this.ballUpperLimit * scaleY;
                    this.ballLineLabelContainer.style.left = `${labelLeftX}px`;
                    // Position so the gap between top text and line equals gap between line and bottom text
                    // The container's vertical center should align with the line
                    this.ballLineLabelContainer.style.top = `${ballLineY}px`;
                    this.ballLineLabelContainer.style.transform = 'translateY(-50%)';
                    
                    // Basket line label - same positioning logic
                    const basketLineY = this.basketLineY * scaleY;
                    this.basketLineLabelContainer.style.left = `${labelLeftX}px`;
                    this.basketLineLabelContainer.style.top = `${basketLineY}px`;
                    this.basketLineLabelContainer.style.transform = 'translateY(-50%)';
                    
                    // D) Offset ball/basket spawn X if they would overlap with labels
                    // Only apply offset for Level 1 when labels are visible
                    if (this.ballSpawnX < minBallBasketX) {
                        this.ballSpawnX = minBallBasketX;
                    }
                    if (this.basket && this.basket.x < minBallBasketX) {
                        this.basket.x = minBallBasketX;
                    }
                }
            }
            
            checkLevel1ObjectPlacement(shape) {
                if (this.level !== 1 || this.level1PlacedOutside) return;
                
                // Check if shape is fully outside piece area
                const shapeLeft = shape.x - 50;  // Approximate bounds
                const shapeRight = shape.x + 50;
                const shapeTop = shape.y - 50;
                const shapeBottom = shape.y + 50;
                
                const pieceAreaRight = this.pieceAreaX + this.pieceAreaWidth;
                const pieceAreaBottom = this.pieceAreaY + this.pieceAreaHeight;
                
                // Shape is outside if any edge is outside piece area bounds
                const isOutside = shapeTop < this.pieceAreaY || 
                                  shapeBottom > pieceAreaBottom ||
                                  shapeLeft < this.pieceAreaX ||
                                  shapeRight > pieceAreaRight;
                
                if (isOutside) {
                    this.level1PlacedOutside = true;
                    this.dragInstructionLabel.classList.add('hidden');
                }
            }
            
            onLevel1FirstSubmit() {
                if (this.level !== 1 || this.level1FirstSubmitDone) return;
                
                this.level1FirstSubmitDone = true;
                this.ballLineLabelContainer.classList.add('hidden');
                this.basketLineLabelContainer.classList.add('hidden');
            }
            
            updateStars(livesRemaining) {
                const star1 = document.getElementById('star1');
                const star2 = document.getElementById('star2');
                const star3 = document.getElementById('star3');
                
                [star1, star2, star3].forEach(s => s.classList.remove('filled'));
                
                const ratio = livesRemaining / this.initialLives;
                let stars = 1;
                if (ratio >= 0.7) stars = 3;
                else if (ratio >= 0.4) stars = 2;
                
                setTimeout(() => {
                    if (stars >= 1) star1.classList.add('filled');
                    if (stars >= 2) star2.classList.add('filled');
                    if (stars >= 3) star3.classList.add('filled');
                }, 200);
            }
            
            init() {
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
                window.addEventListener('orientationchange', () => {
                    setTimeout(() => this.resizeCanvas(), 100);
                });
                this.startBtn.addEventListener('click', () => this.startGame());
                this.startBtn.addEventListener('touchend', (e) => { e.preventDefault(); this.startGame(); });
                
                this.canvas.addEventListener('mousedown', (e) => this.onPointerDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.onPointerMove(e));
                this.canvas.addEventListener('mouseup', () => this.onPointerUp());
                this.canvas.addEventListener('mouseleave', () => this.onPointerUp());
                
                this.canvas.addEventListener('touchstart', (e) => { 
                    e.preventDefault(); 
                    const t = e.touches[0]; 
                    const r = this.canvas.getBoundingClientRect(); 
                    this.handlePointerDown((t.clientX - r.left) * (this.canvas.width / r.width), (t.clientY - r.top) * (this.canvas.height / r.height)); 
                }, { passive: false });
                this.canvas.addEventListener('touchmove', (e) => { 
                    e.preventDefault(); 
                    const t = e.touches[0]; 
                    const r = this.canvas.getBoundingClientRect(); 
                    this.handlePointerMove((t.clientX - r.left) * (this.canvas.width / r.width), (t.clientY - r.top) * (this.canvas.height / r.height)); 
                }, { passive: false });
                this.canvas.addEventListener('touchend', (e) => { e.preventDefault(); this.onPointerUp(); }, { passive: false });
                this.canvas.addEventListener('touchcancel', () => this.onPointerUp());
                
                window.addEventListener('keydown', (e) => { 
                    if (e.key === 'd' || e.key === 'D') { 
                        this.debugMode = !this.debugMode; 
                        this.debugOverlay.style.display = this.debugMode ? 'block' : 'none'; 
                    } 
                });
                this.nextLevelBtn.addEventListener('click', () => this.nextLevel());
                this.retryBtn.addEventListener('click', () => this.retry());
                
                // Powerup popover events
                this.powerupOverlay.addEventListener('click', () => this.closePowerupPopover());
                this.powerupUseBtn.addEventListener('click', () => this.usePowerup());
                
                // R Powerup popover events
                this.rPowerupUseBtn.addEventListener('click', () => this.useRemovePowerup());
                this.removeSelectionOverlay.addEventListener('click', (e) => this.handleRemoveSelectionClick(e));
                this.removeSelectionOverlay.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    if (e.changedTouches.length > 0) {
                        const touch = e.changedTouches[0];
                        this.handleRemoveSelectionClick({
                            clientX: touch.clientX,
                            clientY: touch.clientY
                        });
                    }
                }, { passive: false });
                
                // E Powerup popover events
                this.ePowerupUseBtn.addEventListener('click', () => this.useWidenPowerup());
                
                this.gameLoop(0);
            }
            
            // Powerup button bounds
            getPowerupButtonBounds(index) {
                const w = this.canvas.width;
                const h = this.canvas.height;
                const L = LAYOUT;
                const powerupY = h - L.powerupAreaHeight;
                const powerupBtnSize = L.powerupButtonSize;
                const powerupBtnY = powerupY + (L.powerupAreaHeight - powerupBtnSize) / 2;
                const powerupSpacing = (w - powerupBtnSize * 3) / 4;
                const btnX = powerupSpacing + index * (powerupBtnSize + powerupSpacing);
                return { x: btnX, y: powerupBtnY, w: powerupBtnSize, h: powerupBtnSize };
            }
            
            openPowerupPopover() {
                // Only allow during edit mode
                if (this.state !== 'edit') return;
                // Allow opening if already used (to show "Used" state) OR if count > 0
                if (this.trajectoryPowerupCount <= 0 && !this.tUsedThisLevel) return;
                
                this.powerupPopoverOpen = true;
                this.powerupOverlay.classList.add('active');
                this.powerupPopover.classList.add('active');
                
                // Update button state based on tUsedThisLevel
                if (this.tUsedThisLevel) {
                    this.powerupUseBtn.textContent = 'Used';
                    this.powerupUseBtn.classList.add('disabled');
                } else {
                    this.powerupUseBtn.textContent = 'Use';
                    this.powerupUseBtn.classList.remove('disabled');
                }
                
                // Position popover and nub relative to T button
                requestAnimationFrame(() => {
                    const containerRect = this.container.getBoundingClientRect();
                    const canvasRect = this.canvas.getBoundingClientRect();
                    const tBounds = this.getPowerupButtonBounds(0);
                    
                    // Convert canvas coordinates to container-relative pixels
                    const scaleX = canvasRect.width / this.canvas.width;
                    const buttonCenterX = (tBounds.x + tBounds.w / 2) * scaleX;
                    
                    const popoverRect = this.powerupPopover.getBoundingClientRect();
                    const popoverWidth = popoverRect.width;
                    
                    // Calculate popover left position (try to center on button, but clamp to viewport)
                    const margin = 12;
                    let popoverLeft = buttonCenterX - popoverWidth / 2;
                    popoverLeft = Math.max(margin, Math.min(popoverLeft, containerRect.width - popoverWidth - margin));
                    
                    // Calculate nub position inside popover
                    let nubX = buttonCenterX - popoverLeft;
                    // Clamp nub to stay inside popover bounds
                    nubX = Math.max(18, Math.min(nubX, popoverWidth - 18));
                    
                    this.powerupPopover.style.left = popoverLeft + 'px';
                    this.powerupPopover.style.setProperty('--nub-x', nubX + 'px');
                });
            }
            
            closePowerupPopover() {
                this.powerupPopoverOpen = false;
                this.powerupOverlay.classList.remove('active');
                this.powerupPopover.classList.remove('active');
            }
            
            usePowerup() {
                // Guard: prevent double-use in same level
                if (this.tUsedThisLevel) return;
                if (this.trajectoryPowerupCount <= 0) return;
                
                this.trajectoryPowerupCount--;
                this.trajectoryExtended = true;
                this.tUsedThisLevel = true;  // Mark as used for this level
                
                // Set run-persistent modifier (Task B)
                this.runModifiers.trajectoryMultiplier = 2;
                this.runModifiers.trajectoryPowerUsed = true;
                
                this.closePowerupPopover();
            }
            
            // ===== R POWERUP (Remove Object) =====
            openRPowerupPopover() {
                // Only allow during edit mode
                if (this.state !== 'edit') return;
                // Allow opening if already used (to show "Used" state) OR if count > 0
                if (this.removePowerupCount <= 0 && !this.rUsedThisLevel) return;
                
                this.rPopoverOpen = true;
                this.powerupOverlay.classList.add('active');
                this.rPowerupPopover.classList.add('active');
                
                // Update button state based on rUsedThisLevel
                if (this.rUsedThisLevel) {
                    this.rPowerupUseBtn.textContent = 'Used';
                    this.rPowerupUseBtn.classList.add('disabled');
                } else {
                    this.rPowerupUseBtn.textContent = 'Use';
                    this.rPowerupUseBtn.classList.remove('disabled');
                }
                
                // Position popover and nub relative to R button (index 1)
                requestAnimationFrame(() => {
                    const containerRect = this.container.getBoundingClientRect();
                    const canvasRect = this.canvas.getBoundingClientRect();
                    const rBounds = this.getPowerupButtonBounds(1);
                    
                    // Convert canvas coordinates to container-relative pixels
                    const scaleX = canvasRect.width / this.canvas.width;
                    const buttonCenterX = (rBounds.x + rBounds.w / 2) * scaleX;
                    
                    const popoverRect = this.rPowerupPopover.getBoundingClientRect();
                    const popoverWidth = popoverRect.width;
                    
                    // Calculate popover left position (try to center on button, but clamp to viewport)
                    const margin = 12;
                    let popoverLeft = buttonCenterX - popoverWidth / 2;
                    popoverLeft = Math.max(margin, Math.min(popoverLeft, containerRect.width - popoverWidth - margin));
                    
                    // Calculate nub position inside popover
                    let nubX = buttonCenterX - popoverLeft;
                    nubX = Math.max(18, Math.min(nubX, popoverWidth - 18));
                    
                    this.rPowerupPopover.style.left = popoverLeft + 'px';
                    this.rPowerupPopover.style.setProperty('--nub-x', nubX + 'px');
                });
            }
            
            closeRPowerupPopover() {
                this.rPopoverOpen = false;
                this.powerupOverlay.classList.remove('active');
                this.rPowerupPopover.classList.remove('active');
            }
            
            useRemovePowerup() {
                // Guard: prevent double-use in same level
                if (this.rUsedThisLevel) return;
                if (this.removePowerupCount <= 0) return;
                
                // Close popover and enter selection mode
                this.closeRPowerupPopover();
                this.enterRemoveSelectionMode();
            }
            
            enterRemoveSelectionMode() {
                this.selectRemoveTargetMode = true;
                this.removeSelectionOverlay.classList.add('active');
            }
            
            exitRemoveSelectionMode() {
                this.selectRemoveTargetMode = false;
                this.removeSelectionOverlay.classList.remove('active');
            }
            
            handleRemoveSelectionClick(e) {
                if (!this.selectRemoveTargetMode) return;
                
                // Get click coordinates relative to canvas
                const rect = this.canvas.getBoundingClientRect();
                const scaleX = this.canvas.width / rect.width;
                const scaleY = this.canvas.height / rect.height;
                const x = (e.clientX - rect.left) * scaleX;
                const y = (e.clientY - rect.top) * scaleY;
                
                // Check if click is on any visible shape
                for (let i = this.shapes.length - 1; i >= 0; i--) {
                    const shape = this.shapes[i];
                    if (!shape.isVisible()) continue;
                    
                    if (shape.containsPoint(x, y)) {
                        // Remove this shape using existing hit-removal logic
                        shape.hasBeenHit = true;
                        shape.hasBeenMoved = true;  // Mark as moved so it doesn't block checkAllShapesPlaced
                        shape.removedByPowerup = true;  // Mark as removed by powerup (persists after failed submit)
                        shape.startDisappear();
                        
                        // Decrement count and mark as used
                        this.removePowerupCount--;
                        this.rUsedThisLevel = true;
                        
                        // Exit selection mode
                        this.exitRemoveSelectionMode();
                        
                        // Recheck placement status - trajectory should show if all REMAINING shapes are placed
                        this.allShapesPlacedInitially = this.checkAllShapesPlaced();
                        this.canSubmit = this.state === 'edit' && this.allShapesPlacedInitially && this.lives > 0;
                        return;
                    }
                }
                
                // Clicked elsewhere - cancel selection mode without spending
                this.exitRemoveSelectionMode();
            }
            
            // ===== E POWERUP (Widen Basket) =====
            openEPowerupPopover() {
                // Only allow during edit mode
                if (this.state !== 'edit') return;
                // Allow opening if already used (to show "Used" state) OR if count > 0
                if (this.widenPowerupCount <= 0 && !this.eUsedThisLevel) return;
                
                this.ePopoverOpen = true;
                this.powerupOverlay.classList.add('active');
                this.ePowerupPopover.classList.add('active');
                
                // Update button state based on eUsedThisLevel
                if (this.eUsedThisLevel) {
                    this.ePowerupUseBtn.textContent = 'Used';
                    this.ePowerupUseBtn.classList.add('disabled');
                } else {
                    this.ePowerupUseBtn.textContent = 'Use';
                    this.ePowerupUseBtn.classList.remove('disabled');
                }
                
                // Position popover and nub relative to E button (index 2)
                requestAnimationFrame(() => {
                    const containerRect = this.container.getBoundingClientRect();
                    const canvasRect = this.canvas.getBoundingClientRect();
                    const eBounds = this.getPowerupButtonBounds(2);
                    
                    // Convert canvas coordinates to container-relative pixels
                    const scaleX = canvasRect.width / this.canvas.width;
                    const buttonCenterX = (eBounds.x + eBounds.w / 2) * scaleX;
                    
                    const popoverRect = this.ePowerupPopover.getBoundingClientRect();
                    const popoverWidth = popoverRect.width;
                    
                    // Calculate popover left position (try to center on button, but clamp to viewport)
                    const margin = 12;
                    let popoverLeft = buttonCenterX - popoverWidth / 2;
                    popoverLeft = Math.max(margin, Math.min(popoverLeft, containerRect.width - popoverWidth - margin));
                    
                    // Calculate nub position inside popover
                    let nubX = buttonCenterX - popoverLeft;
                    nubX = Math.max(18, Math.min(nubX, popoverWidth - 18));
                    
                    this.ePowerupPopover.style.left = popoverLeft + 'px';
                    this.ePowerupPopover.style.setProperty('--nub-x', nubX + 'px');
                });
            }
            
            closeEPowerupPopover() {
                this.ePopoverOpen = false;
                this.powerupOverlay.classList.remove('active');
                this.ePowerupPopover.classList.remove('active');
            }
            
            useWidenPowerup() {
                // Guard: prevent double-use in same level
                if (this.eUsedThisLevel) return;
                if (this.widenPowerupCount <= 0) return;
                
                // Decrement count and mark as used
                this.widenPowerupCount--;
                this.eUsedThisLevel = true;
                this.basketWidened = true;
                
                // Set run-persistent modifier (Task B)
                this.runModifiers.basketWidthMultiplier = 1.3;
                this.runModifiers.basketPowerUsed = true;
                
                // Store original radius if not already stored
                if (this.basketOriginalRadius === null) {
                    this.basketOriginalRadius = this.basket.radius;
                }
                
                // Start widen animation
                this.basketWidenProgress = 0;
                
                // Close popover
                this.closeEPowerupPopover();
            }
            
            startGame() {
                // Reset run tracking
                this.runHighestCompletedLevel = 0;
                
                // Reset run-persistent modifiers (Task B)
                this.runModifiers = {
                    trajectoryMultiplier: 1,
                    basketWidthMultiplier: 1,
                    trajectoryPowerUsed: false,
                    basketPowerUsed: false
                };
                
                this.welcomeScreen.classList.add('hidden');
                setTimeout(() => {
                    this.gameStarted = true;
                    this.setupLevel(1);
                }, 400);
            }
            
            resizeCanvas() {
                const ww = window.innerWidth;
                const wh = window.innerHeight;
                
                let cw, ch;
                if (ww / wh > this.aspectRatio) { 
                    ch = wh; 
                    cw = wh * this.aspectRatio; 
                } else { 
                    cw = ww; 
                    ch = ww / this.aspectRatio; 
                }
                
                const minWidth = 280;
                if (cw < minWidth) {
                    cw = minWidth;
                    ch = minWidth / this.aspectRatio;
                }
                
                this.canvas.width = cw; 
                this.canvas.height = ch;
                this.container.style.width = cw + 'px'; 
                this.container.style.height = ch + 'px';
            }
            
            checkAllShapesHit() {
                return this.shapes.every(s => s.hasBeenHit);
            }
            
            checkAllShapesPlaced() {
                // Only check VISIBLE shapes - removed shapes don't count
                return this.shapes.filter(s => s.isVisible()).every(s => s.hasBeenMoved);
            }
            
            predictTrajectory() {
                // ========================================
                // GHOST SIMULATION - Uses EXACT same physics as runtime
                // This ensures preview matches actual ball behavior
                // ========================================
                const ballRadius = 15 * SIZE_SCALE;
                
                // Ghost ball state (mirrors Ball class state, minimal)
                const ghost = {
                    x: this.ballSpawnX,
                    y: this.ballUpperLimit,
                    vx: 0,
                    vy: 0,
                    radius: ballRadius
                };
                
                // Use EXACT same physics parameters as runtime
                const gravity = this.physics.gravity;
                const restitution = this.physics.restitution;
                const friction = this.physics.friction;
                const substeps = this.physics.substeps;  // CRITICAL: same substeps as runtime
                
                // Simulation parameters
                const dt = 1/60;  // Same as game loop frame rate
                const maxTime = this.trajectoryExtended ? 2.5 : 1.25;
                const maxBounces = 10;
                
                let hitPoint = null;
                let reboundPoints = [];
                let bounceCount = 0;
                let totalTime = 0;
                
                // Distance-based sampling for smooth trajectory
                const MIN_SAMPLE_DIST = 6;
                let lastSampleX = ghost.x;
                let lastSampleY = ghost.y;
                
                // Push starting point
                reboundPoints.push({x: ghost.x, y: ghost.y, time: 0, kind: 'start'});
                
                // Run ghost simulation using EXACT SAME PHYSICS LOOP as runtime
                while (totalTime < maxTime && bounceCount < maxBounces) {
                    const subDt = dt / substeps;
                    
                    // ========================================
                    // SUBSTEPS - Exact same loop as Physics.update()
                    // ========================================
                    for (let sub = 0; sub < substeps; sub++) {
                        // 1. Ball integration (exact same as Ball.update)
                        ghost.vy += gravity * subDt;
                        ghost.x += ghost.vx * subDt;
                        ghost.y += ghost.vy * subDt;
                        
                        // 2. Collision resolution (exact same as resolveShapeCollisions)
                        for (const shape of this.shapes) {
                            if (!shape.isVisible()) continue;
                            
                            const segments = shape.getSegments();
                            for (let segIdx = 0; segIdx < segments.length; segIdx++) {
                                const seg = segments[segIdx];
                                
                                // Use EXACT SAME collision detection as runtime
                                const collision = Utils.resolveSegmentCollision(
                                    { x: ghost.x, y: ghost.y }, ghost.radius, seg
                                );
                                if (!collision) continue;
                                
                                // Check one-way (exact same logic)
                                const oneWayResult = Utils.evaluateOneWayCollision(shape, seg, segIdx);
                                
                                if (oneWayResult.shouldVanish) {
                                    // Ball would vanish here
                                    const collPt = { x: collision.closest.x, y: collision.closest.y };
                                    if (bounceCount === 0) {
                                        hitPoint = { x: collPt.x, y: collPt.y, isVanish: true };
                                        reboundPoints.push({ x: collPt.x, y: collPt.y, time: totalTime, kind: 'vanish' });
                                        return { hitPoint, reboundPoints, hitShape: true, maxSteps: reboundPoints.length, willVanish: true };
                                    } else {
                                        reboundPoints.push({ x: collPt.x, y: collPt.y, time: totalTime, kind: 'end' });
                                        return { hitPoint, reboundPoints, hitShape: true, maxSteps: reboundPoints.length, willVanish: false };
                                    }
                                }
                                
                                // Push ball out (EXACT SAME as runtime)
                                ghost.x += collision.normal.x * collision.penetration;
                                ghost.y += collision.normal.y * collision.penetration;
                                
                                // Reflect velocity (EXACT SAME as runtime)
                                const reflection = Utils.reflectVelocity(
                                    { x: ghost.vx, y: ghost.vy },
                                    collision.normal,
                                    restitution,
                                    friction
                                );
                                
                                if (reflection) {
                                    ghost.vx = reflection.vel.x;
                                    ghost.vy = reflection.vel.y;
                                    
                                    const collPt = { x: collision.closest.x, y: collision.closest.y };
                                    
                                    if (hitPoint === null) {
                                        hitPoint = { x: collPt.x, y: collPt.y };
                                    }
                                    
                                    // Record collision point for trajectory continuity
                                    reboundPoints.push({ x: collPt.x, y: collPt.y, time: totalTime, kind: 'collision' });
                                    lastSampleX = collPt.x;
                                    lastSampleY = collPt.y;
                                    
                                    bounceCount++;
                                }
                            }
                        }
                        
                        // 3. Check basket collision (end trajectory if hit before bounce)
                        if (bounceCount === 0) {
                            for (const seg of this.basket.getSegments()) {
                                const collision = Utils.resolveSegmentCollision(
                                    { x: ghost.x, y: ghost.y }, ghost.radius, seg
                                );
                                if (collision) {
                                    // Ball reaches basket before hitting any shape
                                    return { hitPoint: null, reboundPoints, hitShape: false, maxSteps: reboundPoints.length };
                                }
                            }
                        }
                    }
                    
                    totalTime += dt;
                    
                    // Sample trajectory point (distance-based for smooth dots)
                    const distFromLast = Math.sqrt((ghost.x - lastSampleX) ** 2 + (ghost.y - lastSampleY) ** 2);
                    if (distFromLast >= MIN_SAMPLE_DIST) {
                        reboundPoints.push({ x: ghost.x, y: ghost.y, time: totalTime, kind: bounceCount === 0 ? 'pre' : 'post' });
                        lastSampleX = ghost.x;
                        lastSampleY = ghost.y;
                    }
                    
                    // Safety checks
                    if (!isFinite(ghost.x) || !isFinite(ghost.y) || !isFinite(ghost.vx) || !isFinite(ghost.vy)) {
                        break;
                    }
                    
                    // Check bounds
                    if (ghost.y > this.canvas.height + 100 || ghost.x < -50 || ghost.x > this.canvas.width + 50) {
                        break;
                    }
                    
                    // Ball fell off screen without hitting
                    if (ghost.y > this.canvas.height + 50 && bounceCount === 0) {
                        return { hitPoint: null, reboundPoints, hitShape: false, maxSteps: reboundPoints.length };
                    }
                    
                    if (bounceCount >= maxBounces) break;
                }
                
                // Ensure at least 2 points for rendering
                if (reboundPoints.length === 1) {
                    reboundPoints.push({
                        x: reboundPoints[0].x,
                        y: reboundPoints[0].y + 20,
                        time: 0.1,
                        kind: 'pre'
                    });
                }
                
                return { hitPoint, reboundPoints, hitShape: bounceCount > 0 || hitPoint !== null, maxSteps: reboundPoints.length };
            }
            
            drawTrajectory(ctx) {
                if (this.state !== 'edit' || !this.allShapesPlacedInitially) return;
                
                const trajectory = this.predictTrajectory();
                // Draw if we have at least 2 points (start + collision), regardless of hitShape
                // This ensures wrong-side vanish trajectories still render
                if (trajectory.reboundPoints.length < 2) return;
                
                const points = trajectory.reboundPoints;
                const maxSteps = trajectory.maxSteps;  // Fixed horizon budget
                
                // Aggressive fade constants - fade out early for cleaner appearance
                // These apply to the FIXED HORIZON, not actual path length
                const FADE_START = 0.25;  // Start fading at 25% of horizon
                const FADE_END = 0.65;    // Fully faded by 65% of horizon
                const MAX_ALPHA = 0.85;   // Global max alpha
                
                // Smoothstep helper for smooth fade
                const smoothstep = (edge0, edge1, x) => {
                    const t = Math.max(0, Math.min(1, (x - edge0) / (edge1 - edge0)));
                    return t * t * (3 - 2 * t);
                };
                
                // Calculate fade alpha based on time progress (consistent regardless of collisions)
                // Use total simulation time for fade calculation
                const maxTime = this.trajectoryExtended ? 2.5 : 1.25;
                const getFadeAlpha = (timeProgress) => {
                    if (timeProgress < FADE_START) return MAX_ALPHA;
                    if (timeProgress > FADE_END) return 0;
                    return MAX_ALPHA * smoothstep(FADE_END, FADE_START, timeProgress);
                };
                
                // Draw soft dotted gradient line using time-based progress
                for (let i = 0; i < points.length - 1; i++) {
                    const p1 = points[i];
                    const p2 = points[i + 1];
                    const segLength = Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2);
                    
                    // Get time values for interpolation
                    const time1 = p1.time || 0;
                    const time2 = p2.time || time1 + 0.01;
                    
                    // Draw dots along this segment
                    const numDots = Math.floor(segLength / ANIM.trajectoryDotSpacing);
                    for (let j = 0; j <= numDots; j++) {
                        const t = j / Math.max(1, numDots);
                        const x = p1.x + (p2.x - p1.x) * t;
                        const y = p1.y + (p2.y - p1.y) * t;
                        
                        // Calculate progress based on interpolated time / maxTime (CONSISTENT)
                        const interpolatedTime = time1 + (time2 - time1) * t;
                        const progress = interpolatedTime / maxTime;
                        const alpha = getFadeAlpha(progress);
                        
                        // Skip drawing if fully faded
                        if (alpha < 0.01) continue;
                        
                        const size = Math.max(1.5, 3 * (1 - progress * 0.5));
                        
                        ctx.beginPath();
                        ctx.arc(x, y, size, 0, Math.PI * 2);
                        ctx.fillStyle = THEME.trajectoryStart;
                        ctx.globalAlpha = alpha;
                        ctx.fill();
                    }
                }
                ctx.globalAlpha = 1;
                
                // Draw direction ticks/arrowheads along trajectory using time-based progress
                let lastTickDist = 0;
                let accumulatedDist = 0;
                for (let i = 0; i < points.length - 1; i++) {
                    const p1 = points[i];
                    const p2 = points[i + 1];
                    const dx = p2.x - p1.x;
                    const dy = p2.y - p1.y;
                    const segLength = Math.sqrt(dx * dx + dy * dy);
                    const angle = Math.atan2(dy, dx);
                    
                    const time1 = p1.time || 0;
                    const time2 = p2.time || time1 + 0.01;
                    
                    // Draw ticks at intervals
                    let segDist = 0;
                    while (segDist < segLength) {
                        const distFromStart = accumulatedDist + segDist;
                        if (distFromStart - lastTickDist >= ANIM.trajectoryTickSpacing && distFromStart > 20) {
                            const t = segDist / segLength;
                            const x = p1.x + dx * t;
                            const y = p1.y + dy * t;
                            
                            // Calculate progress based on interpolated time (CONSISTENT)
                            const interpolatedTime = time1 + (time2 - time1) * t;
                            const progress = interpolatedTime / maxTime;
                            const alpha = getFadeAlpha(progress) * 0.7; // Ticks slightly more subtle
                            
                            // Skip drawing if fully faded
                            if (alpha < 0.01) {
                                segDist += ANIM.trajectoryTickSpacing;
                                continue;
                            }
                            
                            // Draw small arrowhead
                            ctx.save();
                            ctx.translate(x, y);
                            ctx.rotate(angle);
                            ctx.beginPath();
                            ctx.moveTo(ANIM.trajectoryTickSize, 0);
                            ctx.lineTo(-ANIM.trajectoryTickSize * 0.5, -ANIM.trajectoryTickSize * 0.6);
                            ctx.lineTo(-ANIM.trajectoryTickSize * 0.5, ANIM.trajectoryTickSize * 0.6);
                            ctx.closePath();
                            ctx.fillStyle = THEME.trajectoryTick;
                            ctx.globalAlpha = alpha;
                            ctx.fill();
                            ctx.restore();
                            
                            lastTickDist = distFromStart;
                        }
                        segDist += ANIM.trajectoryTickSpacing;
                    }
                    
                    accumulatedDist += segLength;
                }
                ctx.globalAlpha = 1;
                
                // Draw pulsing ring at first impact point (always fully visible)
                if (trajectory.hitPoint) {
                    const pulse = 0.5 + Math.sin(this.time * ANIM.trajectoryPulseSpeed * Math.PI) * 0.5;
                    
                    // Check if this is a vanish point (wrong side hit)
                    if (trajectory.willVanish) {
                        // Draw X marker at vanish point in one-way highlight color (NO glow)
                        const size = 10 + pulse * 3;
                        ctx.save();
                        ctx.translate(trajectory.hitPoint.x, trajectory.hitPoint.y);
                        ctx.rotate(Math.PI / 4);
                        
                        ctx.strokeStyle = THEME.oneWayHighlight;
                        ctx.lineWidth = 3;
                        ctx.globalAlpha = 0.8;
                        ctx.lineCap = 'round';
                        
                        // Draw X (no glow)
                        ctx.beginPath();
                        ctx.moveTo(-size, 0);
                        ctx.lineTo(size, 0);
                        ctx.moveTo(0, -size);
                        ctx.lineTo(0, size);
                        ctx.stroke();
                        
                        ctx.restore();
                    } else {
                        // Normal impact ring
                        const outerRadius = 8 + pulse * 4;
                        const innerRadius = 4;
                        
                        // Outer glow ring
                        ctx.beginPath();
                        ctx.arc(trajectory.hitPoint.x, trajectory.hitPoint.y, outerRadius, 0, Math.PI * 2);
                        ctx.strokeStyle = THEME.trajectoryImpactGlow;
                        ctx.lineWidth = 3;
                        ctx.globalAlpha = 0.3 + pulse * 0.3;
                        ctx.stroke();
                        
                        // Inner solid ring
                        ctx.beginPath();
                        ctx.arc(trajectory.hitPoint.x, trajectory.hitPoint.y, innerRadius, 0, Math.PI * 2);
                        ctx.fillStyle = THEME.trajectoryImpact;
                        ctx.globalAlpha = 0.7;
                        ctx.fill();
                    }
                    
                    ctx.globalAlpha = 1;
                }
            }
            
            getTrajectoryLength(points) {
                let length = 0;
                for (let i = 0; i < points.length - 1; i++) {
                    const dx = points[i + 1].x - points[i].x;
                    const dy = points[i + 1].y - points[i].y;
                    length += Math.sqrt(dx * dx + dy * dy);
                }
                return length;
            }
            
            // Get accurate AABB half-extents for a shape type in LOCAL space
            // Returns {hx, hy} where hx = half-width, hy = half-height
            // Includes visual padding for stroke/glow
            getLocalAABBHalfExtents(type) {
                const VISUAL_PAD = 12; // Padding for stroke, glow, shadow
                
                // All dimensions already include SIZE_SCALE in createShape
                switch(type) {
                    case ShapeTypeEnum.TRIANGLE_LEFT:
                    case ShapeTypeEnum.TRIANGLE_RIGHT: {
                        // Triangle: 70*SIZE_SCALE x 70*SIZE_SCALE = 45.5 x 45.5
                        const w = 70 * SIZE_SCALE;
                        const h = 70 * SIZE_SCALE;
                        return { hx: w/2 + VISUAL_PAD, hy: h/2 + VISUAL_PAD };
                    }
                    case ShapeTypeEnum.LINE: {
                        // Line: length = sqrt(70^2+70^2) * SIZE_SCALE ≈ 64px
                        // At any rotation, max extent is half-length (diagonal case)
                        const length = Math.sqrt(70*70 + 70*70) * SIZE_SCALE;
                        const halfLen = length / 2;
                        // Line can be at any angle, so use half-length for both axes
                        return { hx: halfLen + VISUAL_PAD, hy: halfLen + VISUAL_PAD };
                    }
                    case ShapeTypeEnum.HALF_CIRCLE: {
                        // HalfCircle: radius = 40 * SIZE_SCALE = 26px
                        // Full circle bounds, plus flat side offset
                        const r = 40 * SIZE_SCALE;
                        return { hx: r + VISUAL_PAD, hy: r + VISUAL_PAD };
                    }
                    case ShapeTypeEnum.DIAMOND: {
                        // Diamond: halfW=50*SIZE_SCALE=32.5, halfH=70*SIZE_SCALE/2=22.75
                        const hw = 50 * SIZE_SCALE;
                        const hh = (70 * SIZE_SCALE) / 2;
                        return { hx: hw + VISUAL_PAD, hy: hh + VISUAL_PAD };
                    }
                    case ShapeTypeEnum.OCTAGON: {
                        // Octagon: radius = 35 * SIZE_SCALE = 22.75
                        const r = 35 * SIZE_SCALE;
                        return { hx: r + VISUAL_PAD, hy: r + VISUAL_PAD };
                    }
                    case ShapeTypeEnum.TRAPEZOID: {
                        // Trapezoid: topWidth=40, bottomWidth=70, height=50 (all * SIZE_SCALE)
                        const maxW = 70 * SIZE_SCALE; // bottom is wider
                        const h = 50 * SIZE_SCALE;
                        return { hx: maxW/2 + VISUAL_PAD, hy: h/2 + VISUAL_PAD };
                    }
                    case ShapeTypeEnum.ARROWHEAD: {
                        // Arrowhead: width=63, height=75 (all * SIZE_SCALE)
                        const w = 63 * SIZE_SCALE;
                        const h = 75 * SIZE_SCALE;
                        return { hx: w/2 + VISUAL_PAD, hy: h/2 + VISUAL_PAD };
                    }
                    case ShapeTypeEnum.BOOMERANG: {
                        // Boomerang: width=76, armWidth=15, height=70 (all * SIZE_SCALE)
                        const w = 76 * SIZE_SCALE;
                        const h = 70 * SIZE_SCALE;
                        return { hx: w/2 + VISUAL_PAD, hy: h/2 + VISUAL_PAD };
                    }
                    case ShapeTypeEnum.HALF_PIPE: {
                        // HalfPipe: width=75, height=56 (all * SIZE_SCALE)
                        const w = 75 * SIZE_SCALE;
                        const h = 56 * SIZE_SCALE;
                        return { hx: w/2 + VISUAL_PAD, hy: h/2 + VISUAL_PAD };
                    }
                    case ShapeTypeEnum.SAWTOOTH_RAMP: {
                        // SawtoothRamp: width=70, height=50 (all * SIZE_SCALE)
                        const w = 70 * SIZE_SCALE;
                        const h = 50 * SIZE_SCALE;
                        return { hx: w/2 + VISUAL_PAD, hy: h/2 + VISUAL_PAD };
                    }
                    default:
                        return { hx: 50, hy: 50 }; // Safe fallback
                }
            }
            
            createShape(type, x, y, rand, colorIndex) {
                switch(type) {
                    case ShapeTypeEnum.TRIANGLE_LEFT:
                        return new Triangle(x, y, 70, 70, 'left', colorIndex);
                    case ShapeTypeEnum.TRIANGLE_RIGHT:
                        return new Triangle(x, y, 70, 70, 'right', colorIndex);
                    case ShapeTypeEnum.LINE:
                        return new LineSegment(x, y, Math.sqrt(70*70 + 70*70), (rand() - 0.5) * Math.PI, colorIndex);
                    case ShapeTypeEnum.HALF_CIRCLE:
                        return new HalfCircle(x, y, 40, colorIndex);
                    case ShapeTypeEnum.DIAMOND:
                        return new Diamond(x, y, 50, 70, colorIndex);
                    case ShapeTypeEnum.OCTAGON:
                        return new Octagon(x, y, 35, colorIndex);
                    case ShapeTypeEnum.TRAPEZOID:
                        return new Trapezoid(x, y, 40, 70, 50, colorIndex);
                    case ShapeTypeEnum.ARROWHEAD:
                        return new Arrowhead(x, y, 63, 75, colorIndex);
                    case ShapeTypeEnum.BOOMERANG:
                        return new Boomerang(x, y, 76, 15, 70, colorIndex);
                    case ShapeTypeEnum.HALF_PIPE:
                        return new HalfPipe(x, y, 75, 56, 12, colorIndex);
                    case ShapeTypeEnum.SAWTOOTH_RAMP:
                        return new SawtoothRamp(x, y, 70, 50, 6, colorIndex);
                }
            }
            
            setupLevel(levelNum, useSeed = null) {
                // ========================================
                // CRITICAL STATE RESET (Safari freeze fix)
                // Must reset state that could persist from previous level
                // ========================================
                this.failQueued = false;
                this.failReason = null;
                this.failStartTime = 0;
                this.attemptLifeCharged = false;
                
                // Reset VFX (clear particles/confetti from previous level win)
                this.vfx.reset();
                
                // Reset physics collision tracking
                this.physics.resetCollisionTracking();
                
                this.level = levelNum;
                this.tUsedThisLevel = false;  // Reset per-level powerup flag
                this.trajectoryExtended = false;  // Reset trajectory extension
                this.rUsedThisLevel = false;  // Reset R per-level powerup flag
                this.selectRemoveTargetMode = false;  // Exit selection mode if active
                this.removeSelectionOverlay.classList.remove('active');  // Hide selection overlay
                // Reset E powerup state
                this.eUsedThisLevel = false;
                this.basketWidened = false;
                this.basketWidenProgress = 1;
                this.basketOriginalRadius = null;
                // Close any open popovers
                this.powerupPopoverOpen = false;
                this.rPopoverOpen = false;
                this.ePopoverOpen = false;
                this.powerupOverlay.classList.remove('active');
                this.powerupPopover.classList.remove('active');
                this.rPowerupPopover.classList.remove('active');
                this.ePowerupPopover.classList.remove('active');
                const w = this.canvas.width, h = this.canvas.height;
                this.levelSeed = useSeed !== null ? useSeed : Math.random() + levelNum;
                let seed = this.levelSeed;
                const rand = () => { seed = (seed * 9301 + 49297) % 233280; return seed / 233280; };
                
                // ========================================
                // DETERMINISTIC LEVEL DATA FROM CSV
                // ========================================
                const csvConfig = getLevelConfigFromCSV(levelNum);
                
                if (csvConfig) {
                    // Use deterministic CSV data
                    this.gravityLevel = csvConfig.gravity;
                    this.reboundLevel = csvConfig.rebound;
                    
                    // Debug output
                    console.log(`[LEVELDATA] Level ${levelNum}:`);
                    console.log(`  count=${csvConfig.objectCount}`);
                    console.log(`  objects=[${csvConfig.objectIds.join(',')}]`);
                    console.log(`  gravity=${csvConfig.gravity}`);
                    console.log(`  rebound=${csvConfig.rebound}`);
                    console.log(`  oneWayIds=[${csvConfig.onewayIds.join(',')}]`);
                    console.log(`  oneWaySides=${JSON.stringify(csvConfig.onewaySides)}`);
                } else {
                    // Fallback for levels beyond CSV
                    console.warn(`[LEVELDATA] Level ${levelNum} not in CSV, using fallback Normal/Normal`);
                    this.gravityLevel = 'Normal';
                    this.reboundLevel = 'Normal';
                }
                
                // Apply specs to physics engine
                this.physics.setLevelSpecs(this.gravityLevel, this.reboundLevel);
                
                const L = LAYOUT;
                const ballRadius = 15 * SIZE_SCALE;
                
                // Ball line position
                this.ballUpperLimit = L.levelDataAreaHeight + L.ballLineOffsetFromTop;
                
                // Bottom controls area is just above powerups
                this.bottomControlsY = h - L.powerupAreaHeight - L.bottomControlsHeight;
                
                // Basket line is above controls area, offset by basketLineExtraOffset from bottom areas
                this.basketLineY = this.bottomControlsY - L.basketLineExtraOffset;
                
                // Piece area - positioned above basket line with specified gap
                this.pieceAreaHeight = L.pieceAreaHeight;
                this.pieceAreaY = this.basketLineY - L.pieceAreaAboveBasket - this.pieceAreaHeight;
                this.pieceAreaX = L.pieceAreaMargin;
                this.pieceAreaWidth = w - L.pieceAreaMargin * 2;
                
                // Ball position - use pieceAreaMargin as safe zone
                const ballOnLeft = rand() > 0.5;
                const halfWidth = w / 2;
                // Use pieceAreaMargin + extra padding for ball spawn safe zone
                const safeMargin = L.pieceAreaMargin + ballRadius + 10;
                
                let ballX;
                if (ballOnLeft) {
                    // Left half: from safeMargin to halfWidth - safeMargin
                    ballX = safeMargin + rand() * (halfWidth - safeMargin * 2);
                } else {
                    // Right half: from halfWidth + safeMargin to width - safeMargin
                    ballX = halfWidth + safeMargin + rand() * (halfWidth - safeMargin * 2);
                }
                this.ball = new Ball(ballX, this.ballUpperLimit, ballRadius);
                this.ballSpawnX = ballX;
                
                // Basket - use pieceAreaMargin as safe zone
                const basketRadius = 35 * SIZE_SCALE;
                const basketSafeMargin = L.pieceAreaMargin + basketRadius + 10;
                let basketX;
                if (ballOnLeft) {
                    // Basket on right half
                    basketX = halfWidth + basketSafeMargin + rand() * (halfWidth - basketSafeMargin * 2);
                } else {
                    // Basket on left half
                    basketX = basketSafeMargin + rand() * (halfWidth - basketSafeMargin * 2);
                }
                this.basket = new Basket(basketX, this.basketLineY, basketRadius);
                this.basket.lidOpen = false;
                
                // ========================================
                // APPLY RUN-PERSISTENT MODIFIERS (Task B)
                // ========================================
                // Apply basket width multiplier from previous T/E usage
                if (this.runModifiers.basketPowerUsed) {
                    const baseRadius = this.basket.radius;
                    this.basket.radius = baseRadius * this.runModifiers.basketWidthMultiplier;
                    this.basketOriginalRadius = baseRadius;  // Store for animation reference
                    this.basketWidened = true;  // Mark as widened
                    this.basketWidenProgress = 1;  // Already complete (no animation)
                    this.eUsedThisLevel = true;  // Prevent re-use this level
                }
                
                // Apply trajectory multiplier from previous T usage
                if (this.runModifiers.trajectoryPowerUsed) {
                    this.trajectoryExtended = true;
                    this.tUsedThisLevel = true;  // Prevent re-use this level
                }
                
                // ========================================
                // DETERMINISTIC SHAPE CREATION FROM CSV
                // ========================================
                let selectedTypes = [];
                
                if (csvConfig) {
                    // Convert object IDs to ShapeTypeEnum
                    for (const objId of csvConfig.objectIds) {
                        const shapeType = OBJECT_ID_MAP[objId];
                        if (shapeType) {
                            selectedTypes.push(shapeType);
                        } else {
                            console.warn(`[LEVELDATA] Unknown object ID ${objId}, skipping`);
                        }
                    }
                } else {
                    // Fallback: use old random generation for levels beyond CSV
                    const targetCount = levelNum <= 5 ? 3 : (levelNum <= 10 ? 4 : 5);
                    const allShapes = [...NORMAL_SHAPES, ...ODD_SHAPES];
                    for (let i = 0; i < targetCount; i++) {
                        selectedTypes.push(allShapes[Math.floor(rand() * allShapes.length)]);
                    }
                }
                
                // Debug: log palette composition
                console.log(`  Palette: [${selectedTypes.map(t => t).join(', ')}] (${selectedTypes.length} shapes)`);
                
                // Calculate AABB half-extents for all shapes
                const shapeExtents = selectedTypes.map(t => this.getLocalAABBHalfExtents(t));
                const shapeHalfWidths = shapeExtents.map(e => e.hx);
                
                // Position shapes in piece area using per-item half-widths
                const numShapes = selectedTypes.length;
                const BOX_INNER_PAD = 8; // Inner padding from box edges
                const boxLeft = this.pieceAreaX + BOX_INNER_PAD;
                const boxRight = this.pieceAreaX + this.pieceAreaWidth - BOX_INNER_PAD;
                const availableWidth = boxRight - boxLeft;
                const centerY = this.pieceAreaY + this.pieceAreaHeight / 2;
                
                // Calculate total required width with desired gap
                const totalShapeWidth = shapeHalfWidths.reduce((sum, hx) => sum + 2 * hx, 0);
                let gap = 20; // Desired gap between shapes
                const minGap = 2; // Minimum gap (reduced for tight fits)
                
                // Reduce gap if needed to fit
                let totalWidth = totalShapeWidth + gap * (numShapes - 1);
                if (totalWidth > availableWidth && numShapes > 1) {
                    gap = Math.max(minGap, (availableWidth - totalShapeWidth) / (numShapes - 1));
                    totalWidth = totalShapeWidth + gap * (numShapes - 1);
                }
                
                // If still doesn't fit, scale down shapes slightly
                let scaleFactor = 1.0;
                if (totalWidth > availableWidth) {
                    scaleFactor = availableWidth / totalWidth;
                    console.warn(`[LEVELDATA] Shapes don't fit, scaling by ${scaleFactor.toFixed(2)}`);
                }
                
                console.log(`  Piece box: left=${boxLeft.toFixed(1)}, right=${boxRight.toFixed(1)}, available=${availableWidth.toFixed(1)}`);
                console.log(`  Shape half-widths: [${shapeHalfWidths.map(h => h.toFixed(1)).join(', ')}]`);
                console.log(`  Total shape width: ${totalShapeWidth.toFixed(1)}, gap: ${gap.toFixed(1)}, total: ${totalWidth.toFixed(1)}`);
                
                // Center the row if there's extra space
                const startX = boxLeft + Math.max(0, (availableWidth - totalWidth * scaleFactor) / 2);
                
                // Position each shape from left to right
                this.shapes = [];
                let currentX = startX;
                
                for (let i = 0; i < numShapes; i++) {
                    const hx = shapeHalfWidths[i] * scaleFactor;
                    const xPos = currentX + hx; // Center of this shape
                    currentX += 2 * hx + (i < numShapes - 1 ? gap * scaleFactor : 0); // Move to next position
                    
                    // Verify no clipping
                    const leftEdge = xPos - hx;
                    const rightEdge = xPos + hx;
                    if (leftEdge < this.pieceAreaX || rightEdge > this.pieceAreaX + this.pieceAreaWidth) {
                        console.warn(`  ⚠ Shape ${i} clips: center=${xPos.toFixed(1)}, hx=${hx.toFixed(1)}, bounds=[${leftEdge.toFixed(1)}, ${rightEdge.toFixed(1)}], box=[${this.pieceAreaX}, ${this.pieceAreaX + this.pieceAreaWidth}]`);
                    }
                    
                    console.log(`  Shape ${i}: type=${selectedTypes[i]}, x=${xPos.toFixed(1)}, hx=${hx.toFixed(1)}, bounds=[${leftEdge.toFixed(1)}, ${rightEdge.toFixed(1)}]`);
                    
                    const shape = this.createShape(selectedTypes[i], xPos, centerY, rand, i);
                    if (shape) {
                        this.shapes.push(shape);
                    } else {
                        console.error(`    ✗ Failed to create shape for type: ${selectedTypes[i]}`);
                    }
                }
                
                console.log(`  Total shapes created: ${this.shapes.length}`);
                
                // Initialize shape properties
                this.shapes.forEach((s, idx) => {
                    s.startX = s.x;
                    s.startY = s.y;
                    s.hasBeenHit = false;
                    s.hasBeenMoved = false;
                    s.isSelected = false;
                    s.oneWayEnabled = false;
                    s.oneWayFaceIndex = -1;
                    s.oneWayAllowedSides = [];
                    s._debugDrawCount = 0;
                });
                
                // ========================================
                // DETERMINISTIC ONE-WAY ASSIGNMENT FROM CSV
                // ========================================
                if (csvConfig && csvConfig.onewayAssignments && csvConfig.onewayAssignments.length > 0) {
                    console.log(`[ONEWAY][CSV] Level ${levelNum}:`);
                    console.log(`  onewayIds=[${csvConfig.onewayIds.join(',')}]`);
                    console.log(`  assignments=${JSON.stringify(csvConfig.onewayAssignments)}`);
                    
                    // Build a map of shape index -> assignment
                    // Match assignments to shapes by object ID in order
                    const assignmentQueue = [...csvConfig.onewayAssignments];
                    const shapeAssignments = new Map();  // shapeIdx -> sides[]
                    
                    // For each assignment, find the corresponding shape
                    for (const assignment of assignmentQueue) {
                        const { objId, sides } = assignment;
                        
                        // Find the next unassigned shape with this object ID
                        for (let shapeIdx = 0; shapeIdx < this.shapes.length; shapeIdx++) {
                            if (shapeAssignments.has(shapeIdx)) continue;  // Already assigned
                            
                            const shapeObjId = csvConfig.objectIds[shapeIdx];
                            if (shapeObjId === objId) {
                                shapeAssignments.set(shapeIdx, sides);
                                break;
                            }
                        }
                    }
                    
                    // Apply assignments to shapes
                    for (const [shapeIdx, sides] of shapeAssignments) {
                        const shape = this.shapes[shapeIdx];
                        const objId = csvConfig.objectIds[shapeIdx];
                        
                        // Check eligibility
                        if (!ONEWAY_ELIGIBLE[objId]) {
                            console.warn(`[ONEWAY] Ignored for ineligible shape: ID ${objId} (${shape.shapeType})`);
                            continue;
                        }
                        
                        shape.oneWayEnabled = true;
                        shape.oneWayAllowedSides = sides;
                        shape.oneWayFaceIndex = sides[0];  // Legacy support
                        
                        console.log(`[ONEWAY][APPLY] shape#${shapeIdx} ${shape.shapeType} -> allowedSides=[${sides.join(',')}]`);
                    }
                    
                    // Final verification: log all shapes' one-way state
                    console.log('[ONEWAY][FINAL] Shape one-way states:');
                    for (let i = 0; i < this.shapes.length; i++) {
                        const s = this.shapes[i];
                        if (s.oneWayEnabled) {
                            console.log(`  [${i}] ${s.shapeType}: ONE-WAY allowedSides=[${s.oneWayAllowedSides.join(',')}]`);
                        } else {
                            console.log(`  [${i}] ${s.shapeType}: normal`);
                        }
                    }
                }
                
                // Show tutorial for Level 4 one-way mechanic
                if (levelNum === 4) {
                    this.showOneWayTutorial();
                }
                
                this.lives = 5;
                this.initialLives = 5;
                this.hasSubmittedOnce = false;
                this.allShapesPlacedInitially = false;
                this.selectedShape = null;
                this.canSubmit = false;
                this.hudAnimProgress = 0;
                
                this.state = 'edit';
                this.gameOverlay.classList.remove('active', 'win', 'fail');
                
                // Initialize Level 1 instructional labels
                this.initLevel1Labels();
            }
            
            submit() {
                if (this.state !== 'edit' || !this.canSubmit) return;
                if (this.lives <= 0) return;  // No lives remaining
                
                // Hide Level 1 line labels on first submit
                this.onLevel1FirstSubmit();
                
                this.lives--;  // Decrement life on each attempt
                this.attemptLifeCharged = true;  // Mark that we charged a life for this attempt
                this.hasSubmittedOnce = true;
                this.shapes.forEach(s => s.savePosition());
                this.state = 'sim';
                this.canSubmit = false;
                
                // Reset fail queue state for new attempt
                this.failQueued = false;
                this.failReason = null;
                this.failStartTime = 0;
                
                // Reset physics collision tracking for one-way logic
                this.physics.resetCollisionTracking();
                
                this.ball.reset(this.ballSpawnX, this.ballUpperLimit);
                this.ball.visible = true;
            }
            
            // Queue a fail condition (idempotent - only triggers once per attempt)
            queueFail(reason, hitPoint = null) {
                if (this.failQueued) return;  // Already queued
                
                if (DEBUG_ONEWAY) {
                    console.log('[ONEWAY] FAIL QUEUED:', reason, hitPoint ? `at (${hitPoint.x.toFixed(1)}, ${hitPoint.y.toFixed(1)})` : '');
                    console.log('[ONEWAY] Fail timer started, lives before fail=', this.lives);
                }
                
                this.failQueued = true;
                this.failReason = reason;
                this.failStartTime = performance.now();
                
                if (reason === 'ONEWAY' && hitPoint) {
                    // Start vanish animation for one-way fail
                    this.ball.startVanish(hitPoint.x, hitPoint.y);
                    // Spawn particles at hit point
                    this.vfx.spawnCollisionParticles(hitPoint.x, hitPoint.y, 0, -1, 200);
                }
            }
            
            // Finish a failed attempt and return to edit or fail screen
            finishAttemptFail() {
                if (DEBUG_ONEWAY) {
                    console.log('[ONEWAY] FAIL FINISHED:', this.failReason, 'lives=', this.lives);
                    console.log('[ONEWAY] Returning to edit state');
                }
                
                // Clear fail queue state
                this.failQueued = false;
                this.failReason = null;
                this.failStartTime = 0;
                this.attemptLifeCharged = false;  // Reset for next attempt
                
                // Use existing returnToEdit which handles lives check
                this.returnToEdit();
            }
            
            // ========================================
            // SAFARI-SAFE LEVEL TRANSITION
            // Defers setupLevel to prevent GPU compositor stall
            // ========================================
            nextLevel() {
                // Prevent double-click race condition
                if (this.isTransitioning) {
                    if (DEBUG_TRANSITIONS) console.log('[TRANSITION] Blocked - already transitioning');
                    return;
                }
                
                const targetLevel = this.level + 1;
                const clickTime = performance.now();
                if (DEBUG_TRANSITIONS) console.log(`[TRANSITION] NextLevel clicked, target=${targetLevel}`);
                
                // Lock transition
                this.isTransitioning = true;
                
                // Safari-specific: enhanced transition handling
                if (IS_SAFARI) {
                    document.body.classList.add('transitioning');
                    this.pauseRender = true;
                    
                    // Force disable backdrop-filter inline as extra safety
                    this.gameOverlay.style.backdropFilter = 'none';
                    this.gameOverlay.style.webkitBackdropFilter = 'none';
                    
                    // Step 1: Hide overlay immediately
                    const hideStart = performance.now();
                    this.gameOverlay.classList.remove('active', 'win', 'fail');
                    
                    // Force style recalc
                    void this.gameOverlay.offsetHeight;
                    const hideTime = performance.now() - hideStart;
                    
                    // Step 2: Yield one frame to let compositor settle
                    requestAnimationFrame(() => {
                        // Step 3: Do heavy setupLevel in next tick (setTimeout)
                        setTimeout(() => {
                            const setupStart = performance.now();
                            
                            // Reset timing to prevent large dt on first frame
                            this.lastTime = performance.now();
                            
                            // Actually set up the level
                            this.setupLevel(targetLevel);
                            
                            const setupTime = performance.now() - setupStart;
                            const totalTime = performance.now() - clickTime;
                            
                            // Update timing info for next overlay
                            this.safariTimingInfo = `Hide: ${hideTime.toFixed(0)}ms, Setup: ${setupTime.toFixed(0)}ms, Total: ${totalTime.toFixed(0)}ms`;
                            
                            // Cleanup Safari state
                            this.gameOverlay.style.backdropFilter = '';
                            this.gameOverlay.style.webkitBackdropFilter = '';
                            document.body.classList.remove('transitioning');
                            this.pauseRender = false;
                            
                            // Resume game loop (was paused by loopPausedForOverlay)
                            this.loopPausedForOverlay = false;
                            
                            // Unlock transition
                            this.isTransitioning = false;
                            
                            // Restart RAF loop
                            requestAnimationFrame((t) => this.gameLoop(t));
                            
                            if (DEBUG_TRANSITIONS) console.log(`[TRANSITION] Complete: ${totalTime.toFixed(0)}ms`);
                        }, 0);
                    });
                } else {
                    // Non-Safari: original behavior with deferred setup
                    this.gameOverlay.classList.remove('active', 'win', 'fail');
                    void this.gameOverlay.offsetHeight;
                    
                    requestAnimationFrame(() => {
                        requestAnimationFrame(() => {
                            setTimeout(() => {
                                this.lastTime = performance.now();
                                this.setupLevel(targetLevel);
                                this.isTransitioning = false;
                            }, 0);
                        });
                    });
                }
            }
            
            retry() { 
                // On fail, return to welcome screen with highest reached displayed
                this.gameOverlay.classList.remove('active', 'win', 'fail');
                this.gameStarted = false;
                
                // Resume game loop if paused (Safari)
                if (IS_SAFARI) {
                    this.loopPausedForOverlay = false;
                }
                
                // Update highest reached display
                this.highestReachedDisplay.style.display = 'block';
                if (this.runHighestCompletedLevel > 0) {
                    this.highestReachedValue.textContent = this.runHighestCompletedLevel.toString();
                } else {
                    this.highestReachedValue.textContent = '—';
                }
                
                // Show welcome screen
                this.welcomeScreen.classList.remove('hidden');
                
                // Restart RAF loop if it was paused (Safari)
                if (IS_SAFARI && !this.loopPausedForOverlay) {
                    requestAnimationFrame((t) => this.gameLoop(t));
                }
            }
            
            onPointerDown(e) { 
                const r = this.canvas.getBoundingClientRect(); 
                this.handlePointerDown(e.clientX - r.left, e.clientY - r.top); 
            }
            onPointerMove(e) { 
                const r = this.canvas.getBoundingClientRect(); 
                this.handlePointerMove(e.clientX - r.left, e.clientY - r.top); 
            }
            
            getAngleBoxBounds() {
                const w = this.canvas.width;
                const L = LAYOUT;
                const boxW = (w - L.controlBoxMargin * 2 - L.controlBoxGap) / 2;
                return {
                    x: L.controlBoxMargin,
                    y: this.bottomControlsY + L.bottomControlsPadding,
                    w: boxW,
                    h: L.controlBoxHeight
                };
            }
            
            getSubmitBoxBounds() {
                const w = this.canvas.width;
                const L = LAYOUT;
                const boxW = (w - L.controlBoxMargin * 2 - L.controlBoxGap) / 2;
                return {
                    x: w - L.controlBoxMargin - boxW,
                    y: this.bottomControlsY + L.bottomControlsPadding,
                    w: boxW,
                    h: L.controlBoxHeight
                };
            }
            
            handlePointerDown(x, y) {
                if (!this.gameStarted) return;
                
                // Dismiss one-way tutorial if active
                if (this.tutorialActive) {
                    this.dismissTutorial();
                    return;
                }
                
                // Check T powerup button (first button)
                const tPowerupBounds = this.getPowerupButtonBounds(0);
                if (x >= tPowerupBounds.x && x <= tPowerupBounds.x + tPowerupBounds.w && 
                    y >= tPowerupBounds.y && y <= tPowerupBounds.y + tPowerupBounds.h) {
                    // Close other popovers if open
                    if (this.rPopoverOpen) {
                        this.closeRPowerupPopover();
                    }
                    if (this.ePopoverOpen) {
                        this.closeEPowerupPopover();
                    }
                    if (this.powerupPopoverOpen) {
                        this.closePowerupPopover();
                    } else {
                        this.openPowerupPopover();
                    }
                    return;
                }
                
                // Check R powerup button (second button)
                const rPowerupBounds = this.getPowerupButtonBounds(1);
                if (x >= rPowerupBounds.x && x <= rPowerupBounds.x + rPowerupBounds.w && 
                    y >= rPowerupBounds.y && y <= rPowerupBounds.y + rPowerupBounds.h) {
                    // Close other popovers if open
                    if (this.powerupPopoverOpen) {
                        this.closePowerupPopover();
                    }
                    if (this.ePopoverOpen) {
                        this.closeEPowerupPopover();
                    }
                    if (this.rPopoverOpen) {
                        this.closeRPowerupPopover();
                    } else {
                        this.openRPowerupPopover();
                    }
                    return;
                }
                
                // Check E powerup button (third button)
                const ePowerupBounds = this.getPowerupButtonBounds(2);
                if (x >= ePowerupBounds.x && x <= ePowerupBounds.x + ePowerupBounds.w && 
                    y >= ePowerupBounds.y && y <= ePowerupBounds.y + ePowerupBounds.h) {
                    // Close other popovers if open
                    if (this.powerupPopoverOpen) {
                        this.closePowerupPopover();
                    }
                    if (this.rPopoverOpen) {
                        this.closeRPowerupPopover();
                    }
                    if (this.ePopoverOpen) {
                        this.closeEPowerupPopover();
                    } else {
                        this.openEPowerupPopover();
                    }
                    return;
                }
                
                // If any popover is open, block other interactions (except powerup area)
                if (this.powerupPopoverOpen || this.rPopoverOpen || this.ePopoverOpen) {
                    return;
                }
                
                // If in remove selection mode, don't process normal interactions
                if (this.selectRemoveTargetMode) {
                    return;
                }
                
                // Check angle box
                const angleBox = this.getAngleBoxBounds();
                if (x >= angleBox.x && x <= angleBox.x + angleBox.w && 
                    y >= angleBox.y && y <= angleBox.y + angleBox.h) {
                    this.angleBoxPressed = true;
                    if (this.selectedShape && this.allShapesPlacedInitially) {
                        this.isSwipingAngle = true;
                        this.swipeStartX = x;
                        this.angleAtSwipeStart = this.selectedShape.rotation;
                    }
                    return;
                }
                
                // Check submit button
                const submitBox = this.getSubmitBoxBounds();
                if (x >= submitBox.x && x <= submitBox.x + submitBox.w && 
                    y >= submitBox.y && y <= submitBox.y + submitBox.h) {
                    this.submitButtonPressed = true;
                    if (this.canSubmit) {
                        this.submit();
                    }
                    return;
                }
                
                if (this.state !== 'edit') return;
                
                // Deselect all shapes first
                this.shapes.forEach(s => s.isSelected = false);
                
                // Check rotate handle
                for (let i = this.shapes.length - 1; i >= 0; i--) {
                    if (this.shapes[i].containsRotateHandle(x, y)) {
                        this.selectedShape = this.shapes[i];
                        this.selectedShape.isSelected = true;
                        this.isRotating = true;
                        return;
                    }
                }
                
                // Check shape body
                for (let i = this.shapes.length - 1; i >= 0; i--) {
                    if (this.shapes[i].containsPoint(x, y)) {
                        this.selectedShape = this.shapes[i];
                        this.selectedShape.isSelected = true;
                        this.isRotating = false;
                        this.selectedShape.isDragging = true;
                        this.selectedShape.dragStartX = this.selectedShape.x;
                        this.selectedShape.dragStartY = this.selectedShape.y;
                        this.dragOffset = { x: x - this.selectedShape.x, y: y - this.selectedShape.y };
                        return;
                    }
                }
                
                // Clicked elsewhere
                this.selectedShape = null;
            }
            
            handlePointerMove(x, y) {
                if (!this.gameStarted) return;
                
                // Handle angle swipe with very low sensitivity
                if (this.isSwipingAngle && this.selectedShape) {
                    const dx = x - this.swipeStartX;
                    // Very low sensitivity: 0.1 degrees per pixel
                    const angleChange = dx * LAYOUT.degreeSwipeSensitivity * Math.PI / 180;
                    this.selectedShape.rotation = this.angleAtSwipeStart + angleChange;
                    return;
                }
                
                if (this.state !== 'edit' || !this.selectedShape) return;
                
                if (this.isRotating) {
                    const c = this.selectedShape.getCenter();
                    this.selectedShape.rotation = Math.atan2(y - c.y, x - c.x) + Math.PI / 2;
                } else if (this.selectedShape.isDragging) {
                    const bottomLimit = this.basketLineY - 10;
                    this.selectedShape.move(
                        x - this.dragOffset.x - this.selectedShape.x, 
                        y - this.dragOffset.y - this.selectedShape.y, 
                        this.canvas.width, 
                        this.canvas.height,
                        bottomLimit
                    );
                }
            }
            
            onPointerUp() {
                this.submitButtonPressed = false;
                this.angleBoxPressed = false;
                
                if (this.isSwipingAngle) {
                    this.isSwipingAngle = false;
                    return;
                }
                
                if (this.selectedShape) {
                    if (!this.isRotating && this.selectedShape.isDragging) {
                        const moved = Math.abs(this.selectedShape.x - this.selectedShape.dragStartX) > 5 || 
                                      Math.abs(this.selectedShape.y - this.selectedShape.dragStartY) > 5;
                        if (moved) {
                            this.selectedShape.hasBeenMoved = true;
                            // Lives system: no cost for adjusting pieces
                            
                            // Check Level 1 object placement for instruction label
                            this.checkLevel1ObjectPlacement(this.selectedShape);
                        }
                        this.selectedShape.isDragging = false;
                    }
                    
                    this.allShapesPlacedInitially = this.checkAllShapesPlaced();
                    this.canSubmit = this.state === 'edit' && this.allShapesPlacedInitially && this.lives > 0;
                }
                
                this.isRotating = false;
            }
            
            gameLoop(timestamp) {
                // ========================================
                // SAFARI: Stop RAF while overlay is shown
                // Prevents GPU compositor stall from blur over canvas
                // ========================================
                if (this.loopPausedForOverlay) {
                    // Don't schedule next frame - wait for user action
                    return;
                }
                
                const dt = Math.min((timestamp - this.lastTime) / 1000, 0.05);
                this.lastTime = timestamp;
                this.time += dt;
                
                if (this.gameStarted) {
                    // HUD pop-in animation
                    if (this.hudAnimProgress < 1) {
                        this.hudAnimProgress = Math.min(1, this.hudAnimProgress + dt * 3);
                    }
                    
                    // HUD state transition (slide up during sim, back down in edit)
                    if (this.state !== this.prevState) {
                        this.targetHudOffset = (this.state === 'sim') ? ANIM.hudStateOffset : 0;
                        this.prevState = this.state;
                    }
                    this.hudStateOffset += (this.targetHudOffset - this.hudStateOffset) * ANIM.hudStateTransitionSpeed * dt;
                    
                    // Submit button pop animation when canSubmit becomes true
                    if (this.canSubmit && !this.wasCanSubmit) {
                        this.submitPopScale = ANIM.submitPopScale;
                        this.submitPopTime = ANIM.submitPopDuration;
                    }
                    this.wasCanSubmit = this.canSubmit;
                    
                    // Decay submit pop
                    if (this.submitPopTime > 0) {
                        this.submitPopTime -= dt;
                        const t = this.submitPopTime / ANIM.submitPopDuration;
                        this.submitPopScale = 1 + (ANIM.submitPopScale - 1) * t;
                    } else {
                        this.submitPopScale = 1;
                    }
                    
                    // Update shapes
                    this.shapes.forEach(s => s.update(dt));
                    
                    // Update basket animation
                    this.basket.update(dt);
                    
                    // Update basket widen animation
                    if (this.basketWidened && this.basketWidenProgress < 1) {
                        this.basketWidenProgress = Math.min(1, this.basketWidenProgress + dt * 4);  // ~250ms
                        // Ease-out: fast at start, slow at end
                        const eased = 1 - Math.pow(1 - this.basketWidenProgress, 3);
                        const targetRadius = this.basketOriginalRadius * 1.30;
                        this.basket.radius = this.basketOriginalRadius + (targetRadius - this.basketOriginalRadius) * eased;
                    }
                    
                    // Update VFX
                    this.vfx.update(dt);
                    
                    // Decay replay swoosh
                    if (this.replaySwooshTime > 0) {
                        this.replaySwooshTime -= dt;
                    }
                    
                    // Animate submit button glow
                    if (this.canSubmit) {
                        this.submitButtonGlow = Math.min(1, this.submitButtonGlow + dt * 3);
                    } else {
                        this.submitButtonGlow = Math.max(0, this.submitButtonGlow - dt * 3);
                    }
                    
                    if (this.state === 'sim') {
                        // ========================================
                        // HARD FAIL WATCHDOG (Task 1A)
                        // Even if failQueued wasn't set correctly, if ball is vanishing
                        // we MUST eventually recover. This is a safety net.
                        // ========================================
                        if (this.ball.vanishing && !this.failQueued) {
                            // Ball is vanishing but failQueued wasn't set - recovery path
                            if (DEBUG_ONEWAY) console.log('[ONEWAY] WATCHDOG: ball.vanishing=true but failQueued=false, forcing queueFail');
                            this.failQueued = true;
                            this.failReason = 'ONEWAY';
                            this.failStartTime = performance.now();
                        }
                        
                        // Check if fail is queued and timer elapsed
                        if (this.failQueued) {
                            const elapsed = performance.now() - this.failStartTime;
                            if (DEBUG_ONEWAY) console.log('[ONEWAY] failQueued branch, elapsed=', elapsed.toFixed(0), 'ms');
                            
                            // Update vanish animation if one-way fail
                            if (this.failReason === 'ONEWAY' && this.ball.vanishing) {
                                this.ball.update(dt, 0);  // Just animate, no gravity
                            }
                            
                            // After 1 second OR vanish complete, finish the failed attempt
                            if (elapsed >= 1000 || this.ball.isVanishComplete()) {
                                if (DEBUG_ONEWAY) console.log('[ONEWAY] Fail timer complete, calling finishAttemptFail');
                                this.finishAttemptFail();
                                if (DEBUG_ONEWAY) console.log('[ONEWAY] finishAttemptFail done, scheduling next frame');
                                // CRITICAL: Always schedule next frame - never let the loop die
                                this.draw();
                                requestAnimationFrame((t) => this.gameLoop(t));
                                return;
                            }
                            
                            // While failing, just draw and continue loop
                            this.draw();
                            requestAnimationFrame((t) => this.gameLoop(t));
                            return;
                        }
                        
                        // Normal physics update (only if not failing)
                        this.physics.update(this.ball, this.shapes, dt, this.basket);
                        
                        // Process collision events for VFX
                        for (const event of this.physics.collisionEvents) {
                            // Check for wrong-side hit (one-way surface)
                            if (event.isWrongSideHit) {
                                // Queue fail with ONEWAY reason
                                this.queueFail('ONEWAY', { x: event.x, y: event.y });
                                continue;
                            }
                            
                            // Spawn particles at collision point
                            this.vfx.spawnCollisionParticles(
                                event.x, event.y,
                                event.normalX, event.normalY,
                                event.speed
                            );
                            
                            // Screen shake for strong impacts
                            if (event.speed > ANIM.shakeThreshold) {
                                const intensity = Math.min(ANIM.shakeIntensity, 
                                    (event.speed - ANIM.shakeThreshold) / 200 * ANIM.shakeIntensity);
                                this.vfx.triggerShake(intensity);
                            }
                        }
                        
                        // Skip win/lose checks if fail was just queued
                        if (this.failQueued) {
                            this.draw();
                            requestAnimationFrame((t) => this.gameLoop(t));
                            return;
                        }
                        
                        // Check if lid should open (with animation)
                        if (!this.basket.targetLidOpen && this.checkAllShapesHit()) {
                            this.basket.openLid();
                        }
                        
                        if (this.ball.y > this.basketLineY + 10) {
                            this.ball.visible = false;
                        }
                        
                        if (this.basket.containsBall(this.ball)) {
                            const overlayStartTime = performance.now();
                            
                            this.state = 'win';
                            
                            // Track highest completed level in this run
                            this.runHighestCompletedLevel = Math.max(this.runHighestCompletedLevel, this.level);
                            
                            this.gameOverlay.classList.remove('fail');
                            this.gameOverlay.classList.add('active', 'win');
                            this.overlayText.textContent = 'SUCCESS!';
                            this.levelCompleteText.textContent = `Level ${this.level} Complete`;
                            this.nextLevelBtn.textContent = `Next Level`;
                            this.updateStars(this.lives);
                            
                            // Trigger win VFX
                            this.basket.triggerWinPulse();
                            this.vfx.spawnConfetti(this.basket.x, this.basket.y);
                            
                            const overlayTime = performance.now() - overlayStartTime;
                            
                            // ========================================
                            // SAFARI: Stop RAF while overlay is shown
                            // Draw one final frame, then pause loop
                            // ========================================
                            if (IS_SAFARI) {
                                this.safariTimingInfo = `Overlay: ${overlayTime.toFixed(0)}ms`;
                                if (this.safariTimingElement) {
                                    this.safariTimingElement.textContent = this.safariTimingInfo;
                                }
                                this.draw();  // One final frame
                                this.loopPausedForOverlay = true;
                                return;  // Exit - don't schedule next RAF
                            }
                        } else if (this.ball.y > this.canvas.height + 100 || this.ball.restTimer > 2 || !this.ball.visible) {
                            this.returnToEdit();
                        }
                    }
                    
                    // Safari: skip draw during level transition to prevent compositor stall
                    if (!this.pauseRender) {
                        this.draw();
                    }
                }
                
                requestAnimationFrame((t) => this.gameLoop(t));
            }
            
            returnToEdit() {
                if (this.lives <= 0) {
                    // Fail - return to welcome screen with highest reached display
                    this.state = 'fail';
                    this.gameOverlay.classList.remove('active', 'win', 'fail');
                    
                    // Update highest reached display on welcome screen
                    if (this.runHighestCompletedLevel > 0) {
                        this.highestReachedValue.textContent = this.runHighestCompletedLevel.toString();
                    } else {
                        this.highestReachedValue.textContent = '—';
                    }
                    
                    // Return to welcome screen
                    this.gameStarted = false;
                    this.welcomeScreen.classList.remove('hidden');
                } else {
                    this.state = 'edit';
                    this.ball.reset(this.ballSpawnX, this.ballUpperLimit);
                    this.ball.visible = true;
                    this.shapes.forEach(s => s.restorePosition());
                    this.basket.reset(); // Reset basket animation state
                    this.canSubmit = this.allShapesPlacedInitially && this.lives > 0;
                    
                    // Trigger replay swoosh effect
                    this.replaySwooshTime = ANIM.swooshDuration;
                    this.vfx.reset();
                }
            }
            
            showOneWayTutorial() {
                // Block gameplay during tutorial
                this.tutorialActive = true;
                
                // Draw tutorial overlay on next frame
                this.tutorialCallback = () => {
                    const ctx = this.ctx;
                    const w = this.canvas.width;
                    const h = this.canvas.height;
                    
                    // Dim background
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(0, 0, w, h);
                    
                    // Popup box dimensions - increased height for larger text
                    const boxW = w * 0.92;
                    const boxH = 280;
                    const boxX = (w - boxW) / 2;
                    const boxY = (h - boxH) / 2;
                    const radius = 16;
                    
                    // Draw popup box with shadow
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                    ctx.shadowBlur = 20;
                    ctx.shadowOffsetY = 4;
                    
                    ctx.fillStyle = THEME.glassBackgroundSolid;
                    ctx.beginPath();
                    ctx.roundRect(boxX, boxY, boxW, boxH, radius);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    
                    // Border
                    ctx.strokeStyle = THEME.glassBorder;
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    
                    // Title: "One-Way Bounce" - doubled from 22 to 44
                    ctx.fillStyle = THEME.textPrimary;
                    ctx.font = `bold ${44 * SIZE_SCALE}px "Inter", system-ui, sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.fillText('One-Way Bounce', w / 2, boxY + 65);
                    
                    // Body text with highlighted "this side" - doubled from 16 to 32
                    const bodyY = boxY + 130;
                    const regularFont = `${32 * SIZE_SCALE}px "Inter", system-ui, sans-serif`;
                    const boldFont = `bold ${32 * SIZE_SCALE}px "Inter", system-ui, sans-serif`;
                    
                    // Draw "Ball will bounce from only "
                    const text1 = 'Ball will bounce from only ';
                    const text2 = 'this side';
                    const text3 = '.';
                    
                    // Measure text1 with regular font
                    ctx.font = regularFont;
                    const text1Width = ctx.measureText(text1).width;
                    
                    // Measure text2 with BOLD font (important: must match the font used for drawing)
                    ctx.font = boldFont;
                    const text2Width = ctx.measureText(text2).width;
                    
                    // Measure text3 with regular font
                    ctx.font = regularFont;
                    const text3Width = ctx.measureText(text3).width;
                    
                    const totalWidth = text1Width + text2Width + text3Width;
                    const startX = (w - totalWidth) / 2;
                    
                    // Draw text1 (regular)
                    ctx.textAlign = 'left';
                    ctx.fillStyle = THEME.textSecondary;
                    ctx.font = regularFont;
                    ctx.fillText(text1, startX, bodyY);
                    
                    // Draw text2 "this side" in one-way color (bold)
                    ctx.fillStyle = THEME.oneWayHighlight;
                    ctx.font = boldFont;
                    ctx.fillText(text2, startX + text1Width, bodyY);
                    
                    // Draw text3 "." (regular)
                    ctx.fillStyle = THEME.textSecondary;
                    ctx.font = regularFont;
                    ctx.fillText(text3, startX + text1Width + text2Width, bodyY);
                    
                    // Instruction to dismiss - doubled from 12 to 24
                    ctx.fillStyle = THEME.textMuted;
                    ctx.font = `${24 * SIZE_SCALE}px "Inter", system-ui, sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.fillText('Tap anywhere to continue', w / 2, boxY + boxH - 35);
                };
            }
            
            dismissTutorial() {
                this.tutorialActive = false;
                this.tutorialCallback = null;
            }
            
            draw() {
                const ctx = this.ctx, w = this.canvas.width, h = this.canvas.height;
                const L = LAYOUT;
                const T = THEME;
                const animEase = Math.min(1, this.hudAnimProgress * this.hudAnimProgress * (3 - 2 * this.hudAnimProgress));
                
                // Apply screen shake
                ctx.save();
                if (this.vfx.screenShake.time > 0) {
                    ctx.translate(this.vfx.screenShake.x, this.vfx.screenShake.y);
                }
                
                // Deep dark background gradient
                const bgGradient = ctx.createLinearGradient(0, 0, w * 0.3, h);
                bgGradient.addColorStop(0, T.bgGradientStart);
                bgGradient.addColorStop(0.5, T.bgGradientMid);
                bgGradient.addColorStop(1, T.bgGradientEnd);
                ctx.fillStyle = bgGradient;
                ctx.fillRect(0, 0, w, h);
                
                // Subtle dot pattern overlay
                if (this.patternCanvas) {
                    const pattern = ctx.createPattern(this.patternCanvas, 'repeat');
                    ctx.fillStyle = pattern;
                    ctx.fillRect(0, 0, w, h);
                }
                
                // Vignette effect - very subtle
                const vignetteGrad = ctx.createRadialGradient(w/2, h/2, h * 0.5, w/2, h/2, h);
                vignetteGrad.addColorStop(0, 'rgba(0, 0, 0, 0)');
                vignetteGrad.addColorStop(1, 'rgba(0, 0, 0, 0.15)');
                ctx.fillStyle = vignetteGrad;
                ctx.fillRect(0, 0, w, h);
                
                // ===== TOP PANEL (Dark Glass) =====
                // Apply both initial animation and state transition offset
                const topOffset = L.levelDataAreaHeight * (1 - animEase) + this.hudStateOffset;
                ctx.save();
                ctx.translate(0, -topOffset);
                
                // Panel background - dark glass
                const panelGrad = ctx.createLinearGradient(0, 0, 0, L.levelDataAreaHeight);
                panelGrad.addColorStop(0, T.panelTopStart);
                panelGrad.addColorStop(1, T.panelTopEnd);
                ctx.fillStyle = panelGrad;
                ctx.fillRect(0, 0, w, L.levelDataAreaHeight);
                
                // Inner highlight - subtle on dark
                ctx.fillStyle = 'rgba(255, 255, 255, 0.05)';
                ctx.fillRect(0, 0, w, 1);
                
                // Bottom border - faint
                ctx.fillStyle = T.panelTopStroke;
                ctx.fillRect(0, L.levelDataAreaHeight - 1, w, 1);
                
                // ===== LIVES PILL =====
                const movesBoxX = L.movesBoxX;
                const movesBoxY = L.movesBoxY;
                
                // Determine lives urgency colors (adjusted thresholds for 5 lives)
                let movesPillStart, movesPillEnd, movesTextColor, movesGlow;
                const livesRatio = this.lives / this.initialLives;
                if (livesRatio > 0.6) {
                    // Good - green tint (4-5 lives)
                    movesPillStart = T.movesGoodStart;
                    movesPillEnd = T.movesGoodEnd;
                    movesTextColor = T.movesGoodText;
                    movesGlow = T.movesGoodGlow;
                } else if (livesRatio > 0.2) {
                    // Warning - yellow tint (2-3 lives)
                    movesPillStart = T.movesWarnStart;
                    movesPillEnd = T.movesWarnEnd;
                    movesTextColor = T.movesWarnText;
                    movesGlow = T.movesWarnGlow;
                } else {
                    // Low - red tint (0-1 lives)
                    movesPillStart = T.movesLowStart;
                    movesPillEnd = T.movesLowEnd;
                    movesTextColor = T.movesLowText;
                    movesGlow = T.movesLowGlow;
                }
                
                // Glow for low lives
                if (this.lives <= 1 && this.state === 'edit') {
                    const pulse = 0.5 + Math.sin(this.time * 4) * 0.5;
                    ctx.shadowColor = movesGlow;
                    ctx.shadowBlur = 15 * pulse;
                }
                
                // Soft shadow on dark
                ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
                ctx.shadowBlur = 12;
                ctx.shadowOffsetY = 3;
                
                // Lives pill gradient fill
                Utils.roundRect(ctx, movesBoxX, movesBoxY, L.movesBoxWidth, L.movesBoxHeight, L.boxCornerRadius);
                const movesPillGrad = ctx.createLinearGradient(movesBoxX, movesBoxY, movesBoxX, movesBoxY + L.movesBoxHeight);
                movesPillGrad.addColorStop(0, movesPillStart);
                movesPillGrad.addColorStop(1, movesPillEnd);
                ctx.fillStyle = movesPillGrad;
                ctx.fill();
                ctx.shadowBlur = 0;
                ctx.shadowOffsetY = 0;
                
                // Subtle border
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.lineWidth = 1;
                Utils.roundRect(ctx, movesBoxX, movesBoxY, L.movesBoxWidth, L.movesBoxHeight, L.boxCornerRadius);
                ctx.stroke();
                
                // Lives label - small
                ctx.font = `700 ${L.movesLabelFontSize}px Nunito, sans-serif`;
                ctx.fillStyle = movesTextColor;
                ctx.globalAlpha = 0.8;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('LIVES', movesBoxX + L.movesBoxWidth/2, movesBoxY + 15);
                ctx.globalAlpha = 1;
                
                // Lives number - big and bold
                ctx.font = `900 ${L.movesNumberFontSize + 6}px Nunito, sans-serif`;
                ctx.fillStyle = movesTextColor;
                ctx.fillText(this.lives, movesBoxX + L.movesBoxWidth/2, movesBoxY + 38);
                
                // ===== SPECS BOX =====
                const specsBoxX = w - L.specsBoxMarginRight - L.specsBoxWidth;
                const specsBoxY = L.specsBoxY;
                
                // Shadow
                ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
                ctx.shadowBlur = 10;
                ctx.shadowOffsetY = 2;
                
                // Specs pill - dark glass
                Utils.roundRect(ctx, specsBoxX, specsBoxY, L.specsBoxWidth, L.specsBoxHeight, L.boxCornerRadius);
                const specsPillGrad = ctx.createLinearGradient(specsBoxX, specsBoxY, specsBoxX, specsBoxY + L.specsBoxHeight);
                specsPillGrad.addColorStop(0, T.specsPillStart);
                specsPillGrad.addColorStop(1, T.specsPillEnd);
                ctx.fillStyle = specsPillGrad;
                ctx.fill();
                ctx.shadowBlur = 0;
                
                // Visible border for contrast
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.lineWidth = 1;
                Utils.roundRect(ctx, specsBoxX, specsBoxY, L.specsBoxWidth, L.specsBoxHeight, L.boxCornerRadius);
                ctx.stroke();
                
                // Specs text - colored based on preset
                ctx.font = `600 ${L.specsFontSize}px Nunito, sans-serif`;
                ctx.textAlign = 'center';
                
                // Gravity line with color
                const gravityColor = GRAVITY_PRESETS[this.gravityLevel].color;
                ctx.fillStyle = gravityColor;
                ctx.fillText(`${this.gravityLevel} Gravity`, specsBoxX + L.specsBoxWidth/2, specsBoxY + 20);
                
                // Rebound line with color
                const reboundColor = REBOUND_PRESETS[this.reboundLevel].color;
                ctx.fillStyle = reboundColor;
                ctx.fillText(`${this.reboundLevel} Rebound`, specsBoxX + L.specsBoxWidth/2, specsBoxY + 38);
                
                // ===== LEVEL DISPLAY =====
                // Bright white text
                ctx.font = `800 ${L.levelFontSize}px Nunito, sans-serif`;
                ctx.fillStyle = '#FFFFFF';
                ctx.textAlign = 'center';
                ctx.fillText(`Level ${this.level}`, w/2, movesBoxY + L.movesBoxHeight/2 + 2);
                
                ctx.restore();
                
                // ===== BALL LINE (spawn line) =====
                ctx.beginPath();
                ctx.moveTo(0, this.ballUpperLimit);
                ctx.lineTo(w, this.ballUpperLimit);
                ctx.strokeStyle = T.spawnLine;
                ctx.lineWidth = 2;
                ctx.setLineDash([10, 8]);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // ===== PIECE AREA =====
                if (!this.allShapesPlacedInitially) {
                    Utils.roundRect(ctx, this.pieceAreaX, this.pieceAreaY, this.pieceAreaWidth, this.pieceAreaHeight, L.pieceAreaCornerRadius);
                    ctx.strokeStyle = T.pieceAreaStroke;
                    ctx.lineWidth = 2;
                    ctx.setLineDash([8, 6]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
                
                // ===== BASKET LINE =====
                ctx.beginPath();
                ctx.moveTo(0, this.basketLineY);
                ctx.lineTo(w, this.basketLineY);
                ctx.strokeStyle = T.basketLine;
                ctx.lineWidth = 2;
                ctx.setLineDash([10, 8]);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // ===== BOTTOM CONTROLS PANEL =====
                const powerupY = h - L.powerupAreaHeight;
                const bottomOffset = (L.bottomControlsHeight + L.powerupAreaHeight) * (1 - animEase);
                
                ctx.save();
                ctx.translate(0, bottomOffset);
                
                // Panel background with tinted gradient
                const bottomPanelGrad = ctx.createLinearGradient(0, this.bottomControlsY, 0, this.bottomControlsY + L.bottomControlsHeight);
                bottomPanelGrad.addColorStop(0, T.panelBottomStart);
                bottomPanelGrad.addColorStop(1, T.panelBottomEnd);
                ctx.fillStyle = bottomPanelGrad;
                ctx.fillRect(0, this.bottomControlsY, w, L.bottomControlsHeight);
                
                // Top border - faint
                ctx.fillStyle = T.panelBottomStroke;
                ctx.fillRect(0, this.bottomControlsY, w, 1);
                
                // ===== ANGLE BOX =====
                const angleBox = this.getAngleBoxBounds();
                const angleScale = this.angleBoxPressed ? ANIM.buttonPressScale : 1;
                
                ctx.save();
                ctx.translate(angleBox.x + angleBox.w/2, angleBox.y + angleBox.h/2);
                ctx.scale(angleScale, angleScale);
                ctx.translate(-(angleBox.x + angleBox.w/2), -(angleBox.y + angleBox.h/2));
                
                ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
                ctx.shadowBlur = 8;
                ctx.shadowOffsetY = 2;
                
                Utils.roundRect(ctx, angleBox.x, angleBox.y, angleBox.w, angleBox.h, L.controlCornerRadius);
                
                if (this.selectedShape && this.allShapesPlacedInitially) {
                    // Active state - CYAN accent (different from purple shape selection)
                    const angleGrad = ctx.createLinearGradient(angleBox.x, angleBox.y, angleBox.x, angleBox.y + angleBox.h);
                    angleGrad.addColorStop(0, T.angleChipActiveStart);
                    angleGrad.addColorStop(1, T.angleChipActiveEnd);
                    ctx.fillStyle = angleGrad;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    ctx.strokeStyle = T.angleChipActiveStroke;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    let angleDeg = (this.selectedShape.rotation * 180 / Math.PI) % 360;
                    if (angleDeg < 0) angleDeg += 360;
                    if (angleDeg > 180) angleDeg = angleDeg - 360;
                    angleDeg = Math.round(angleDeg * 10) / 10;
                    const sign = angleDeg >= 0 ? '+' : '';
                    
                    // Degree value
                    ctx.font = `700 ${L.controlBoxFontSize}px Nunito, sans-serif`;
                    ctx.fillStyle = T.angleChipActiveText || T.secondary;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(`${sign}${angleDeg}°`, angleBox.x + angleBox.w/2, angleBox.y + angleBox.h/2 - 6);
                    
                    // Bidirectional arrow below degree
                    const arrowY = angleBox.y + angleBox.h/2 + 10;
                    const arrowCenterX = angleBox.x + angleBox.w/2;
                    const arrowWidth = 20;
                    ctx.strokeStyle = T.angleChipActiveText || T.secondary;
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    // Left arrow head
                    ctx.moveTo(arrowCenterX - arrowWidth/2 + 4, arrowY - 3);
                    ctx.lineTo(arrowCenterX - arrowWidth/2, arrowY);
                    ctx.lineTo(arrowCenterX - arrowWidth/2 + 4, arrowY + 3);
                    // Line
                    ctx.moveTo(arrowCenterX - arrowWidth/2, arrowY);
                    ctx.lineTo(arrowCenterX + arrowWidth/2, arrowY);
                    // Right arrow head
                    ctx.moveTo(arrowCenterX + arrowWidth/2 - 4, arrowY - 3);
                    ctx.lineTo(arrowCenterX + arrowWidth/2, arrowY);
                    ctx.lineTo(arrowCenterX + arrowWidth/2 - 4, arrowY + 3);
                    ctx.stroke();
                } else {
                    // Inactive state - dark glass neutral
                    const angleGrad = ctx.createLinearGradient(angleBox.x, angleBox.y, angleBox.x, angleBox.y + angleBox.h);
                    angleGrad.addColorStop(0, T.angleChipStart);
                    angleGrad.addColorStop(1, T.angleChipEnd);
                    ctx.fillStyle = angleGrad;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    ctx.strokeStyle = T.angleChipStroke;
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    
                    // "Angle Adjust" text - single line, larger font
                    ctx.font = `600 ${L.controlBoxFontSize - 2}px Nunito, sans-serif`;
                    ctx.fillStyle = T.textSecondary;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('Angle Adjust', angleBox.x + angleBox.w/2, angleBox.y + angleBox.h/2 - 5);
                    
                    // Bidirectional arrow below text - longer
                    const arrowY = angleBox.y + angleBox.h/2 + 12;
                    const arrowCenterX = angleBox.x + angleBox.w/2;
                    const arrowWidth = 32;
                    ctx.strokeStyle = T.textSecondary;
                    ctx.lineWidth = 1.5;
                    ctx.globalAlpha = 0.7;
                    ctx.beginPath();
                    // Left arrow head
                    ctx.moveTo(arrowCenterX - arrowWidth/2 + 5, arrowY - 3);
                    ctx.lineTo(arrowCenterX - arrowWidth/2, arrowY);
                    ctx.lineTo(arrowCenterX - arrowWidth/2 + 5, arrowY + 3);
                    // Line
                    ctx.moveTo(arrowCenterX - arrowWidth/2, arrowY);
                    ctx.lineTo(arrowCenterX + arrowWidth/2, arrowY);
                    // Right arrow head
                    ctx.moveTo(arrowCenterX + arrowWidth/2 - 5, arrowY - 3);
                    ctx.lineTo(arrowCenterX + arrowWidth/2, arrowY);
                    ctx.lineTo(arrowCenterX + arrowWidth/2 - 5, arrowY + 3);
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                }
                ctx.restore();
                
                // ===== SUBMIT BUTTON =====
                const submitBox = this.getSubmitBoxBounds();
                // Combine press scale and pop scale
                let submitScale = this.submitButtonPressed ? ANIM.buttonPressScale : 1;
                submitScale *= this.submitPopScale;
                
                ctx.save();
                ctx.translate(submitBox.x + submitBox.w/2, submitBox.y + submitBox.h/2);
                ctx.scale(submitScale, submitScale);
                ctx.translate(-(submitBox.x + submitBox.w/2), -(submitBox.y + submitBox.h/2));
                
                // Glow when enabled - use themed glow color
                if (this.canSubmit && this.submitButtonGlow > 0) {
                    const pulse = 0.6 + Math.sin(this.time * ANIM.glowPulseSpeed * Math.PI) * 0.4;
                    ctx.shadowColor = T.submitGlow;
                    ctx.shadowBlur = 22 * this.submitButtonGlow * pulse;
                }
                
                Utils.roundRect(ctx, submitBox.x, submitBox.y, submitBox.w, submitBox.h, L.controlCornerRadius);
                
                if (this.canSubmit) {
                    // Primary gradient fill
                    const btnGrad = ctx.createLinearGradient(submitBox.x, submitBox.y, submitBox.x, submitBox.y + submitBox.h);
                    btnGrad.addColorStop(0, T.submitStart);
                    btnGrad.addColorStop(1, T.submitEnd);
                    ctx.fillStyle = btnGrad;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    
                    // Inner highlight
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.25)';
                    ctx.lineWidth = 1;
                    Utils.roundRect(ctx, submitBox.x + 1, submitBox.y + 1, submitBox.w - 2, submitBox.h - 2, L.controlCornerRadius - 1);
                    ctx.stroke();
                    
                    ctx.font = `700 ${L.controlBoxFontSize}px Nunito, sans-serif`;
                    ctx.fillStyle = T.textOnPrimary;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('SUBMIT', submitBox.x + submitBox.w/2, submitBox.y + submitBox.h/2);
                } else {
                    // Disabled state with tinted gradient
                    const disabledGrad = ctx.createLinearGradient(submitBox.x, submitBox.y, submitBox.x, submitBox.y + submitBox.h);
                    disabledGrad.addColorStop(0, T.submitDisabledStart);
                    disabledGrad.addColorStop(1, T.submitDisabledEnd);
                    ctx.fillStyle = disabledGrad;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    
                    // Subtle border for disabled state
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.05)';
                    ctx.lineWidth = 1;
                    Utils.roundRect(ctx, submitBox.x, submitBox.y, submitBox.w, submitBox.h, L.controlCornerRadius);
                    ctx.stroke();
                    
                    ctx.font = `700 ${L.controlBoxFontSize}px Nunito, sans-serif`;
                    ctx.fillStyle = T.textMuted;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('SUBMIT', submitBox.x + submitBox.w/2, submitBox.y + submitBox.h/2);
                }
                ctx.restore();
                
                // ===== POWERUP AREA =====
                // Gradient background
                const powerupPanelGrad = ctx.createLinearGradient(0, powerupY, 0, powerupY + L.powerupAreaHeight);
                powerupPanelGrad.addColorStop(0, T.panelPowerupStart);
                powerupPanelGrad.addColorStop(1, T.panelPowerupEnd);
                ctx.fillStyle = powerupPanelGrad;
                ctx.fillRect(0, powerupY, w, L.powerupAreaHeight);
                
                // Top border - subtle and colored
                ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                ctx.fillRect(0, powerupY, w, 1);
                
                // Powerup buttons with individual tints
                const powerupBtnSize = L.powerupButtonSize;
                const powerupBtnY = powerupY + (L.powerupAreaHeight - powerupBtnSize) / 2;
                const powerupSpacing = (w - powerupBtnSize * 3) / 4;
                const powerups = ['T', 'R', 'E'];
                const powerupStyles = [
                    { start: T.powerup1Start, end: T.powerup1End, stroke: T.powerup1Stroke, text: T.secondary },
                    { start: T.powerup2Start, end: T.powerup2End, stroke: T.powerup2Stroke, text: T.danger },
                    { start: T.powerup3Start, end: T.powerup3End, stroke: T.powerup3Stroke, text: T.accent },
                ];
                
                for (let i = 0; i < 3; i++) {
                    const btnX = powerupSpacing + i * (powerupBtnSize + powerupSpacing);
                    const style = powerupStyles[i];
                    
                    // Check if T button (index 0) is disabled
                    const isTButton = i === 0;
                    const isDisabled = isTButton && this.trajectoryPowerupCount <= 0;
                    
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.1)';
                    ctx.shadowBlur = 8;
                    ctx.shadowOffsetY = 3;
                    
                    Utils.roundRect(ctx, btnX, powerupBtnY, powerupBtnSize, powerupBtnSize, L.boxCornerRadius);
                    
                    if (isDisabled) {
                        // Disabled state - muted colors
                        ctx.fillStyle = 'rgba(100, 116, 139, 0.3)';
                        ctx.fill();
                        ctx.shadowBlur = 0;
                        ctx.strokeStyle = 'rgba(100, 116, 139, 0.4)';
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    } else {
                        // Gradient fill
                        const btnGrad = ctx.createLinearGradient(btnX, powerupBtnY, btnX, powerupBtnY + powerupBtnSize);
                        btnGrad.addColorStop(0, style.start);
                        btnGrad.addColorStop(1, style.end);
                        ctx.fillStyle = btnGrad;
                        ctx.fill();
                        ctx.shadowBlur = 0;
                        
                        // Colored stroke
                        ctx.strokeStyle = style.stroke;
                        ctx.lineWidth = 1.5;
                        ctx.stroke();
                    }
                    
                    // Draw content based on button type
                    if (isTButton) {
                        // Draw trajectory icon for T button
                        const centerX = btnX + powerupBtnSize / 2;
                        const centerY = powerupBtnY + powerupBtnSize / 2;
                        const iconColor = isDisabled ? 'rgba(100, 116, 139, 0.5)' : style.text;
                        
                        ctx.save();
                        ctx.translate(centerX, centerY);
                        
                        // Draw dotted arc trajectory
                        ctx.strokeStyle = iconColor;
                        ctx.lineWidth = 2;
                        ctx.setLineDash([2, 3]);
                        ctx.beginPath();
                        ctx.arc(-8, 4, 14, -Math.PI * 0.8, -Math.PI * 0.15);
                        ctx.stroke();
                        ctx.setLineDash([]);
                        
                        // Draw ball at start
                        ctx.beginPath();
                        ctx.arc(-8, -6, 3.5, 0, Math.PI * 2);
                        ctx.fillStyle = iconColor;
                        ctx.fill();
                        
                        // Draw arrowhead at end
                        ctx.beginPath();
                        ctx.moveTo(8, 0);
                        ctx.lineTo(4, -3);
                        ctx.lineTo(4, 3);
                        ctx.closePath();
                        ctx.fill();
                        
                        ctx.restore();
                        
                        // Draw count badge (bottom-right corner)
                        const badgeX = btnX + powerupBtnSize - 8;
                        const badgeY = powerupBtnY + powerupBtnSize - 8;
                        const badgeRadius = 8;
                        
                        ctx.beginPath();
                        ctx.arc(badgeX, badgeY, badgeRadius, 0, Math.PI * 2);
                        ctx.fillStyle = isDisabled ? 'rgba(100, 116, 139, 0.6)' : T.secondary;
                        ctx.fill();
                        
                        ctx.font = `700 10px Nunito, sans-serif`;
                        ctx.fillStyle = isDisabled ? 'rgba(255, 255, 255, 0.5)' : '#0F172A';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(this.trajectoryPowerupCount.toString(), badgeX, badgeY);
                    } else if (i === 1) {
                        // R Button - Hammer icon
                        const isRDisabled = this.removePowerupCount <= 0;
                        const centerX = btnX + powerupBtnSize / 2;
                        const centerY = powerupBtnY + powerupBtnSize / 2;
                        const iconColor = isRDisabled ? 'rgba(100, 116, 139, 0.5)' : style.text;
                        
                        // Redraw button background if disabled
                        if (isRDisabled) {
                            Utils.roundRect(ctx, btnX, powerupBtnY, powerupBtnSize, powerupBtnSize, L.boxCornerRadius);
                            ctx.fillStyle = 'rgba(100, 116, 139, 0.3)';
                            ctx.fill();
                            ctx.strokeStyle = 'rgba(100, 116, 139, 0.4)';
                            ctx.lineWidth = 1;
                            ctx.stroke();
                        }
                        
                        ctx.save();
                        ctx.translate(centerX, centerY);
                        
                        // Draw hammer icon
                        ctx.fillStyle = iconColor;
                        ctx.strokeStyle = iconColor;
                        ctx.lineWidth = 2;
                        
                        // Hammer head (rectangle, rotated)
                        ctx.save();
                        ctx.rotate(-Math.PI / 4);  // 45 degree rotation
                        ctx.fillRect(-10, -5, 12, 10);  // Hammer head
                        ctx.restore();
                        
                        // Hammer handle
                        ctx.beginPath();
                        ctx.moveTo(-2, 2);
                        ctx.lineTo(8, 12);
                        ctx.lineWidth = 3;
                        ctx.lineCap = 'round';
                        ctx.stroke();
                        
                        ctx.restore();
                        
                        // Draw count badge (bottom-right corner)
                        const badgeX = btnX + powerupBtnSize - 8;
                        const badgeY = powerupBtnY + powerupBtnSize - 8;
                        const badgeRadius = 8;
                        
                        ctx.beginPath();
                        ctx.arc(badgeX, badgeY, badgeRadius, 0, Math.PI * 2);
                        ctx.fillStyle = isRDisabled ? 'rgba(100, 116, 139, 0.6)' : T.danger;
                        ctx.fill();
                        
                        ctx.font = `700 10px Nunito, sans-serif`;
                        ctx.fillStyle = isRDisabled ? 'rgba(255, 255, 255, 0.5)' : '#0F172A';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(this.removePowerupCount.toString(), badgeX, badgeY);
                    } else if (i === 2) {
                        // E Button - Widen arrow icon
                        const isEDisabled = this.widenPowerupCount <= 0;
                        const centerX = btnX + powerupBtnSize / 2;
                        const centerY = powerupBtnY + powerupBtnSize / 2;
                        const iconColor = isEDisabled ? 'rgba(100, 116, 139, 0.5)' : style.text;
                        
                        // Redraw button background if disabled
                        if (isEDisabled) {
                            Utils.roundRect(ctx, btnX, powerupBtnY, powerupBtnSize, powerupBtnSize, L.boxCornerRadius);
                            ctx.fillStyle = 'rgba(100, 116, 139, 0.3)';
                            ctx.fill();
                            ctx.strokeStyle = 'rgba(100, 116, 139, 0.4)';
                            ctx.lineWidth = 1;
                            ctx.stroke();
                        }
                        
                        ctx.save();
                        ctx.translate(centerX, centerY);
                        
                        // Draw double-sided arrow icon (← →)
                        ctx.strokeStyle = iconColor;
                        ctx.fillStyle = iconColor;
                        ctx.lineWidth = 2.5;
                        ctx.lineCap = 'round';
                        
                        // Center horizontal line
                        ctx.beginPath();
                        ctx.moveTo(-10, 0);
                        ctx.lineTo(10, 0);
                        ctx.stroke();
                        
                        // Left arrowhead
                        ctx.beginPath();
                        ctx.moveTo(-10, 0);
                        ctx.lineTo(-5, -5);
                        ctx.moveTo(-10, 0);
                        ctx.lineTo(-5, 5);
                        ctx.stroke();
                        
                        // Right arrowhead
                        ctx.beginPath();
                        ctx.moveTo(10, 0);
                        ctx.lineTo(5, -5);
                        ctx.moveTo(10, 0);
                        ctx.lineTo(5, 5);
                        ctx.stroke();
                        
                        ctx.restore();
                        
                        // Draw count badge (bottom-right corner)
                        const badgeX = btnX + powerupBtnSize - 8;
                        const badgeY = powerupBtnY + powerupBtnSize - 8;
                        const badgeRadius = 8;
                        
                        ctx.beginPath();
                        ctx.arc(badgeX, badgeY, badgeRadius, 0, Math.PI * 2);
                        ctx.fillStyle = isEDisabled ? 'rgba(100, 116, 139, 0.6)' : T.accent;
                        ctx.fill();
                        
                        ctx.font = `700 10px Nunito, sans-serif`;
                        ctx.fillStyle = isEDisabled ? 'rgba(255, 255, 255, 0.5)' : '#0F172A';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(this.widenPowerupCount.toString(), badgeX, badgeY);
                    }
                }
                
                ctx.restore();
                
                // ===== REPLAY SWOOSH EFFECT =====
                if (this.replaySwooshTime > 0) {
                    const swooshAlpha = this.replaySwooshTime / ANIM.swooshDuration;
                    const swooshGlow = Math.sin(swooshAlpha * Math.PI) * 0.6;
                    
                    // Highlight ball spawn line
                    ctx.beginPath();
                    ctx.moveTo(0, this.ballUpperLimit);
                    ctx.lineTo(w, this.ballUpperLimit);
                    ctx.strokeStyle = THEME.swooshColor;
                    ctx.lineWidth = 4;
                    ctx.globalAlpha = swooshGlow;
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                    
                    // Highlight basket line
                    ctx.beginPath();
                    ctx.moveTo(0, this.basketLineY);
                    ctx.lineTo(w, this.basketLineY);
                    ctx.strokeStyle = THEME.swooshColor;
                    ctx.lineWidth = 4;
                    ctx.globalAlpha = swooshGlow;
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                }
                
                // ===== TRAJECTORY =====
                if (this.state === 'edit') {
                    this.drawTrajectory(ctx);
                }
                
                // ===== GAME OBJECTS (Normal render - BEFORE selection overlay) =====
                if (!this.selectRemoveTargetMode) {
                    // Normal mode: draw everything normally
                    this.basket.draw(ctx);
                    for (const shape of this.shapes) {
                        // Debug: track first draw call
                        if (shape._debugDrawCount === 0) {
                            console.log(`  [DRAW] First draw of ${shape.shapeType} at (${shape.x.toFixed(1)}, ${shape.y.toFixed(1)}), visible=${shape.isVisible()}`);
                        }
                        shape._debugDrawCount = (shape._debugDrawCount || 0) + 1;
                        shape.draw(ctx, shape === this.selectedShape);
                    }
                    this.ball.draw(ctx);
                } else {
                    // Selection mode: draw everything FIRST (will be under the tint)
                    this.basket.draw(ctx);
                    for (const shape of this.shapes) {
                        shape.draw(ctx, false);  // Draw without selection highlight
                    }
                    this.ball.draw(ctx);
                    
                    // ===== SELECTION MODE OVERLAY =====
                    // Draw heavier dim overlay AFTER ball/basket/shapes
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.65)';
                    ctx.fillRect(0, 0, w, h - L.powerupAreaHeight);
                    
                    // ===== RE-DRAW ONLY SHAPES ABOVE TINT =====
                    // Draw shapes with uniform neutral style + pulsing glow
                    const glowPulse = 0.6 + 0.3 * Math.sin(this.time * 4);  // Pulsing glow
                    
                    for (const shape of this.shapes) {
                        if (!shape.isVisible()) continue;
                        
                        ctx.save();
                        ctx.globalAlpha = shape.opacity;
                        
                        // Outer glow (pulsing)
                        ctx.shadowColor = `rgba(248, 113, 113, ${glowPulse})`;
                        ctx.shadowBlur = 18 + 6 * Math.sin(this.time * 4);
                        
                        // Draw shape with NEUTRAL colors (same for all, regardless of selection)
                        const neutralFill = 'rgba(148, 163, 184, 0.35)';
                        const neutralStroke = 'rgba(248, 113, 113, 0.95)';  // Red-ish stroke for selection mode
                        
                        if (shape.shapeType === ShapeTypeEnum.LINE) {
                            // Line segment
                            const e = shape.getEndpoints();
                            
                            // Main line
                            ctx.beginPath();
                            ctx.moveTo(e.a.x, e.a.y);
                            ctx.lineTo(e.b.x, e.b.y);
                            ctx.strokeStyle = neutralStroke;
                            ctx.lineWidth = 4;
                            ctx.lineCap = 'round';
                            ctx.stroke();
                            
                            // Endpoint circles (filled with stroke color like original)
                            [e.a, e.b].forEach(p => {
                                ctx.beginPath();
                                ctx.arc(p.x, p.y, 5, 0, Math.PI * 2);
                                ctx.fillStyle = neutralStroke;
                                ctx.fill();
                            });
                        } else if (shape.shapeType === ShapeTypeEnum.HALF_CIRCLE) {
                            // Half circle
                            ctx.beginPath();
                            ctx.arc(shape.x, shape.y, shape.radius, shape.rotation, shape.rotation + Math.PI);
                            ctx.closePath();
                            ctx.fillStyle = neutralFill;
                            ctx.fill();
                            ctx.strokeStyle = neutralStroke;
                            ctx.lineWidth = 3;
                            ctx.stroke();
                        } else if (shape.getVertices) {
                            // Any polygon shape (Triangle, Diamond, Octagon, Trapezoid)
                            const v = shape.getVertices();
                            ctx.beginPath();
                            ctx.moveTo(v[0].x, v[0].y);
                            for (let i = 1; i < v.length; i++) {
                                ctx.lineTo(v[i].x, v[i].y);
                            }
                            ctx.closePath();
                            ctx.fillStyle = neutralFill;
                            ctx.fill();
                            ctx.strokeStyle = neutralStroke;
                            ctx.lineWidth = 3;
                            ctx.lineJoin = 'round';
                            ctx.stroke();
                        }
                        
                        ctx.shadowBlur = 0;
                        ctx.restore();
                    }
                    
                    // ===== HINT TEXT (on top of everything) =====
                    // Semi-transparent pill background for readability
                    const hintText = 'Tap an object to remove';
                    const hintY = h - L.powerupAreaHeight - 30;
                    
                    // Adaptive font size
                    let fontSize = 18;
                    ctx.font = `700 ${fontSize}px Nunito, sans-serif`;
                    let textWidth = ctx.measureText(hintText).width;
                    const maxWidth = w - 40;
                    while (textWidth > maxWidth && fontSize > 12) {
                        fontSize -= 1;
                        ctx.font = `700 ${fontSize}px Nunito, sans-serif`;
                        textWidth = ctx.measureText(hintText).width;
                    }
                    
                    // Draw pill background
                    const pillPadX = 16, pillPadY = 8;
                    const pillW = textWidth + pillPadX * 2;
                    const pillH = fontSize + pillPadY * 2;
                    const pillX = (w - pillW) / 2;
                    const pillY = hintY - pillH / 2;
                    
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                    Utils.roundRect(ctx, pillX, pillY, pillW, pillH, pillH / 2);
                    ctx.fill();
                    
                    // Draw text
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(hintText, w / 2, hintY);
                }
                
                // ===== VFX (particles, confetti) =====
                this.vfx.draw(ctx);
                
                // Restore from screen shake
                ctx.restore();
                
                // ===== ONE-WAY TUTORIAL OVERLAY =====
                if (this.tutorialActive && this.tutorialCallback) {
                    this.tutorialCallback();
                }
            }
        }

        window.addEventListener('load', () => new Game());
    </script>
</body>
</html>
